// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package repositories

import (
	"database/sql"
	"github.com/wakamenod/suito/api/repositories"
	"github.com/wakamenod/suito/model"
	"sync"
	"time"
)

// Ensure, that RepositoryMock does implement Repository.
// If this is not the case, regenerate this file with moq.
var _ Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of Repository.
//
//	func TestSomethingThatUsesRepository(t *testing.T) {
//
//		// make and configure a mocked Repository
//		mockedRepository := &RepositoryMock{
//			CreateExpenseFunc: func(uid string, expense model.Expense) (model.Expense, error) {
//				panic("mock out the CreateExpense method")
//			},
//			CreateIncomeFunc: func(uid string, income model.Income) (model.Income, error) {
//				panic("mock out the CreateIncome method")
//			},
//			DeleteExpenseFunc: func(id string, uid string) error {
//				panic("mock out the DeleteExpense method")
//			},
//			FindAllUIDsFunc: func() ([]string, error) {
//				panic("mock out the FindAllUIDs method")
//			},
//			FindColumnChartExpenseDataFunc: func(uid string) ([]repositories.ColumnChartData, error) {
//				panic("mock out the FindColumnChartExpenseData method")
//			},
//			FindColumnChartIncomeDataFunc: func(uid string) ([]repositories.ColumnChartData, error) {
//				panic("mock out the FindColumnChartIncomeData method")
//			},
//			FindExpenseFunc: func(id string, uid string) (model.Expense, error) {
//				panic("mock out the FindExpense method")
//			},
//			FindExpenseCategoriesFunc: func(uid string) ([]model.ExpenseCategory, error) {
//				panic("mock out the FindExpenseCategories method")
//			},
//			FindExpenseCategoryFunc: func(id string, uid string) (model.ExpenseCategory, error) {
//				panic("mock out the FindExpenseCategory method")
//			},
//			FindExpenseLocationFunc: func(id string, uid string) (model.ExpenseLocation, error) {
//				panic("mock out the FindExpenseLocation method")
//			},
//			FindExpenseLocationsFunc: func(uid string) ([]model.ExpenseLocation, error) {
//				panic("mock out the FindExpenseLocations method")
//			},
//			FindExpensesFunc: func(uid string, start *time.Time, end *time.Time) ([]model.Expense, error) {
//				panic("mock out the FindExpenses method")
//			},
//			FindIncomeFunc: func(id string, uid string) (model.Income, error) {
//				panic("mock out the FindIncome method")
//			},
//			FindIncomeTypesFunc: func(uid string) ([]model.IncomeType, error) {
//				panic("mock out the FindIncomeTypes method")
//			},
//			FindIncomesFunc: func(uid string, start *time.Time, end *time.Time) ([]model.Income, error) {
//				panic("mock out the FindIncomes method")
//			},
//			FindOrCreateExpenseCategoryFunc: func(uid string, name string) (model.ExpenseCategory, error) {
//				panic("mock out the FindOrCreateExpenseCategory method")
//			},
//			FindOrCreateExpenseLocationFunc: func(uid string, name string) (model.ExpenseLocation, error) {
//				panic("mock out the FindOrCreateExpenseLocation method")
//			},
//			FindOrCreateIncomeTypeFunc: func(uid string, name string) (model.IncomeType, error) {
//				panic("mock out the FindOrCreateIncomeType method")
//			},
//			FindOrCreateUserFunc: func(uid string) (model.User, error) {
//				panic("mock out the FindOrCreateUser method")
//			},
//			FindTransactionMonthsFunc: func(uid string) ([]string, error) {
//				panic("mock out the FindTransactionMonths method")
//			},
//			HardDeleteAllUserExpenseCategoriesFunc: func(uid string) error {
//				panic("mock out the HardDeleteAllUserExpenseCategories method")
//			},
//			HardDeleteAllUserExpenseLocationsFunc: func(uid string) error {
//				panic("mock out the HardDeleteAllUserExpenseLocations method")
//			},
//			HardDeleteAllUserExpensesFunc: func(uid string) error {
//				panic("mock out the HardDeleteAllUserExpenses method")
//			},
//			HardDeleteAllUserIncomesFunc: func(uid string) error {
//				panic("mock out the HardDeleteAllUserIncomes method")
//			},
//			TransactionFunc: func(fc func(txRepo *repositories.SuitoRepository) error, opts ...*sql.TxOptions) error {
//				panic("mock out the Transaction method")
//			},
//			UpdateExpenseFunc: func(uid string, expense model.Expense) (model.Expense, error) {
//				panic("mock out the UpdateExpense method")
//			},
//		}
//
//		// use mockedRepository in code that requires Repository
//		// and then make assertions.
//
//	}
type RepositoryMock struct {
	// CreateExpenseFunc mocks the CreateExpense method.
	CreateExpenseFunc func(uid string, expense model.Expense) (model.Expense, error)

	// CreateIncomeFunc mocks the CreateIncome method.
	CreateIncomeFunc func(uid string, income model.Income) (model.Income, error)

	// DeleteExpenseFunc mocks the DeleteExpense method.
	DeleteExpenseFunc func(id string, uid string) error

	// FindAllUIDsFunc mocks the FindAllUIDs method.
	FindAllUIDsFunc func() ([]string, error)

	// FindColumnChartExpenseDataFunc mocks the FindColumnChartExpenseData method.
	FindColumnChartExpenseDataFunc func(uid string) ([]repositories.ColumnChartData, error)

	// FindColumnChartIncomeDataFunc mocks the FindColumnChartIncomeData method.
	FindColumnChartIncomeDataFunc func(uid string) ([]repositories.ColumnChartData, error)

	// FindExpenseFunc mocks the FindExpense method.
	FindExpenseFunc func(id string, uid string) (model.Expense, error)

	// FindExpenseCategoriesFunc mocks the FindExpenseCategories method.
	FindExpenseCategoriesFunc func(uid string) ([]model.ExpenseCategory, error)

	// FindExpenseCategoryFunc mocks the FindExpenseCategory method.
	FindExpenseCategoryFunc func(id string, uid string) (model.ExpenseCategory, error)

	// FindExpenseLocationFunc mocks the FindExpenseLocation method.
	FindExpenseLocationFunc func(id string, uid string) (model.ExpenseLocation, error)

	// FindExpenseLocationsFunc mocks the FindExpenseLocations method.
	FindExpenseLocationsFunc func(uid string) ([]model.ExpenseLocation, error)

	// FindExpensesFunc mocks the FindExpenses method.
	FindExpensesFunc func(uid string, start *time.Time, end *time.Time) ([]model.Expense, error)

	// FindIncomeFunc mocks the FindIncome method.
	FindIncomeFunc func(id string, uid string) (model.Income, error)

	// FindIncomeTypesFunc mocks the FindIncomeTypes method.
	FindIncomeTypesFunc func(uid string) ([]model.IncomeType, error)

	// FindIncomesFunc mocks the FindIncomes method.
	FindIncomesFunc func(uid string, start *time.Time, end *time.Time) ([]model.Income, error)

	// FindOrCreateExpenseCategoryFunc mocks the FindOrCreateExpenseCategory method.
	FindOrCreateExpenseCategoryFunc func(uid string, name string) (model.ExpenseCategory, error)

	// FindOrCreateExpenseLocationFunc mocks the FindOrCreateExpenseLocation method.
	FindOrCreateExpenseLocationFunc func(uid string, name string) (model.ExpenseLocation, error)

	// FindOrCreateIncomeTypeFunc mocks the FindOrCreateIncomeType method.
	FindOrCreateIncomeTypeFunc func(uid string, name string) (model.IncomeType, error)

	// FindOrCreateUserFunc mocks the FindOrCreateUser method.
	FindOrCreateUserFunc func(uid string) (model.User, error)

	// FindTransactionMonthsFunc mocks the FindTransactionMonths method.
	FindTransactionMonthsFunc func(uid string) ([]string, error)

	// HardDeleteAllUserExpenseCategoriesFunc mocks the HardDeleteAllUserExpenseCategories method.
	HardDeleteAllUserExpenseCategoriesFunc func(uid string) error

	// HardDeleteAllUserExpenseLocationsFunc mocks the HardDeleteAllUserExpenseLocations method.
	HardDeleteAllUserExpenseLocationsFunc func(uid string) error

	// HardDeleteAllUserExpensesFunc mocks the HardDeleteAllUserExpenses method.
	HardDeleteAllUserExpensesFunc func(uid string) error

	// HardDeleteAllUserIncomesFunc mocks the HardDeleteAllUserIncomes method.
	HardDeleteAllUserIncomesFunc func(uid string) error

	// TransactionFunc mocks the Transaction method.
	TransactionFunc func(fc func(txRepo *repositories.SuitoRepository) error, opts ...*sql.TxOptions) error

	// UpdateExpenseFunc mocks the UpdateExpense method.
	UpdateExpenseFunc func(uid string, expense model.Expense) (model.Expense, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateExpense holds details about calls to the CreateExpense method.
		CreateExpense []struct {
			// UID is the uid argument value.
			UID string
			// Expense is the expense argument value.
			Expense model.Expense
		}
		// CreateIncome holds details about calls to the CreateIncome method.
		CreateIncome []struct {
			// UID is the uid argument value.
			UID string
			// Income is the income argument value.
			Income model.Income
		}
		// DeleteExpense holds details about calls to the DeleteExpense method.
		DeleteExpense []struct {
			// ID is the id argument value.
			ID string
			// UID is the uid argument value.
			UID string
		}
		// FindAllUIDs holds details about calls to the FindAllUIDs method.
		FindAllUIDs []struct {
		}
		// FindColumnChartExpenseData holds details about calls to the FindColumnChartExpenseData method.
		FindColumnChartExpenseData []struct {
			// UID is the uid argument value.
			UID string
		}
		// FindColumnChartIncomeData holds details about calls to the FindColumnChartIncomeData method.
		FindColumnChartIncomeData []struct {
			// UID is the uid argument value.
			UID string
		}
		// FindExpense holds details about calls to the FindExpense method.
		FindExpense []struct {
			// ID is the id argument value.
			ID string
			// UID is the uid argument value.
			UID string
		}
		// FindExpenseCategories holds details about calls to the FindExpenseCategories method.
		FindExpenseCategories []struct {
			// UID is the uid argument value.
			UID string
		}
		// FindExpenseCategory holds details about calls to the FindExpenseCategory method.
		FindExpenseCategory []struct {
			// ID is the id argument value.
			ID string
			// UID is the uid argument value.
			UID string
		}
		// FindExpenseLocation holds details about calls to the FindExpenseLocation method.
		FindExpenseLocation []struct {
			// ID is the id argument value.
			ID string
			// UID is the uid argument value.
			UID string
		}
		// FindExpenseLocations holds details about calls to the FindExpenseLocations method.
		FindExpenseLocations []struct {
			// UID is the uid argument value.
			UID string
		}
		// FindExpenses holds details about calls to the FindExpenses method.
		FindExpenses []struct {
			// UID is the uid argument value.
			UID string
			// Start is the start argument value.
			Start *time.Time
			// End is the end argument value.
			End *time.Time
		}
		// FindIncome holds details about calls to the FindIncome method.
		FindIncome []struct {
			// ID is the id argument value.
			ID string
			// UID is the uid argument value.
			UID string
		}
		// FindIncomeTypes holds details about calls to the FindIncomeTypes method.
		FindIncomeTypes []struct {
			// UID is the uid argument value.
			UID string
		}
		// FindIncomes holds details about calls to the FindIncomes method.
		FindIncomes []struct {
			// UID is the uid argument value.
			UID string
			// Start is the start argument value.
			Start *time.Time
			// End is the end argument value.
			End *time.Time
		}
		// FindOrCreateExpenseCategory holds details about calls to the FindOrCreateExpenseCategory method.
		FindOrCreateExpenseCategory []struct {
			// UID is the uid argument value.
			UID string
			// Name is the name argument value.
			Name string
		}
		// FindOrCreateExpenseLocation holds details about calls to the FindOrCreateExpenseLocation method.
		FindOrCreateExpenseLocation []struct {
			// UID is the uid argument value.
			UID string
			// Name is the name argument value.
			Name string
		}
		// FindOrCreateIncomeType holds details about calls to the FindOrCreateIncomeType method.
		FindOrCreateIncomeType []struct {
			// UID is the uid argument value.
			UID string
			// Name is the name argument value.
			Name string
		}
		// FindOrCreateUser holds details about calls to the FindOrCreateUser method.
		FindOrCreateUser []struct {
			// UID is the uid argument value.
			UID string
		}
		// FindTransactionMonths holds details about calls to the FindTransactionMonths method.
		FindTransactionMonths []struct {
			// UID is the uid argument value.
			UID string
		}
		// HardDeleteAllUserExpenseCategories holds details about calls to the HardDeleteAllUserExpenseCategories method.
		HardDeleteAllUserExpenseCategories []struct {
			// UID is the uid argument value.
			UID string
		}
		// HardDeleteAllUserExpenseLocations holds details about calls to the HardDeleteAllUserExpenseLocations method.
		HardDeleteAllUserExpenseLocations []struct {
			// UID is the uid argument value.
			UID string
		}
		// HardDeleteAllUserExpenses holds details about calls to the HardDeleteAllUserExpenses method.
		HardDeleteAllUserExpenses []struct {
			// UID is the uid argument value.
			UID string
		}
		// HardDeleteAllUserIncomes holds details about calls to the HardDeleteAllUserIncomes method.
		HardDeleteAllUserIncomes []struct {
			// UID is the uid argument value.
			UID string
		}
		// Transaction holds details about calls to the Transaction method.
		Transaction []struct {
			// Fc is the fc argument value.
			Fc func(txRepo *repositories.SuitoRepository) error
			// Opts is the opts argument value.
			Opts []*sql.TxOptions
		}
		// UpdateExpense holds details about calls to the UpdateExpense method.
		UpdateExpense []struct {
			// UID is the uid argument value.
			UID string
			// Expense is the expense argument value.
			Expense model.Expense
		}
	}
	lockCreateExpense                      sync.RWMutex
	lockCreateIncome                       sync.RWMutex
	lockDeleteExpense                      sync.RWMutex
	lockFindAllUIDs                        sync.RWMutex
	lockFindColumnChartExpenseData         sync.RWMutex
	lockFindColumnChartIncomeData          sync.RWMutex
	lockFindExpense                        sync.RWMutex
	lockFindExpenseCategories              sync.RWMutex
	lockFindExpenseCategory                sync.RWMutex
	lockFindExpenseLocation                sync.RWMutex
	lockFindExpenseLocations               sync.RWMutex
	lockFindExpenses                       sync.RWMutex
	lockFindIncome                         sync.RWMutex
	lockFindIncomeTypes                    sync.RWMutex
	lockFindIncomes                        sync.RWMutex
	lockFindOrCreateExpenseCategory        sync.RWMutex
	lockFindOrCreateExpenseLocation        sync.RWMutex
	lockFindOrCreateIncomeType             sync.RWMutex
	lockFindOrCreateUser                   sync.RWMutex
	lockFindTransactionMonths              sync.RWMutex
	lockHardDeleteAllUserExpenseCategories sync.RWMutex
	lockHardDeleteAllUserExpenseLocations  sync.RWMutex
	lockHardDeleteAllUserExpenses          sync.RWMutex
	lockHardDeleteAllUserIncomes           sync.RWMutex
	lockTransaction                        sync.RWMutex
	lockUpdateExpense                      sync.RWMutex
}

// CreateExpense calls CreateExpenseFunc.
func (mock *RepositoryMock) CreateExpense(uid string, expense model.Expense) (model.Expense, error) {
	if mock.CreateExpenseFunc == nil {
		panic("RepositoryMock.CreateExpenseFunc: method is nil but Repository.CreateExpense was just called")
	}
	callInfo := struct {
		UID     string
		Expense model.Expense
	}{
		UID:     uid,
		Expense: expense,
	}
	mock.lockCreateExpense.Lock()
	mock.calls.CreateExpense = append(mock.calls.CreateExpense, callInfo)
	mock.lockCreateExpense.Unlock()
	return mock.CreateExpenseFunc(uid, expense)
}

// CreateExpenseCalls gets all the calls that were made to CreateExpense.
// Check the length with:
//
//	len(mockedRepository.CreateExpenseCalls())
func (mock *RepositoryMock) CreateExpenseCalls() []struct {
	UID     string
	Expense model.Expense
} {
	var calls []struct {
		UID     string
		Expense model.Expense
	}
	mock.lockCreateExpense.RLock()
	calls = mock.calls.CreateExpense
	mock.lockCreateExpense.RUnlock()
	return calls
}

// CreateIncome calls CreateIncomeFunc.
func (mock *RepositoryMock) CreateIncome(uid string, income model.Income) (model.Income, error) {
	if mock.CreateIncomeFunc == nil {
		panic("RepositoryMock.CreateIncomeFunc: method is nil but Repository.CreateIncome was just called")
	}
	callInfo := struct {
		UID    string
		Income model.Income
	}{
		UID:    uid,
		Income: income,
	}
	mock.lockCreateIncome.Lock()
	mock.calls.CreateIncome = append(mock.calls.CreateIncome, callInfo)
	mock.lockCreateIncome.Unlock()
	return mock.CreateIncomeFunc(uid, income)
}

// CreateIncomeCalls gets all the calls that were made to CreateIncome.
// Check the length with:
//
//	len(mockedRepository.CreateIncomeCalls())
func (mock *RepositoryMock) CreateIncomeCalls() []struct {
	UID    string
	Income model.Income
} {
	var calls []struct {
		UID    string
		Income model.Income
	}
	mock.lockCreateIncome.RLock()
	calls = mock.calls.CreateIncome
	mock.lockCreateIncome.RUnlock()
	return calls
}

// DeleteExpense calls DeleteExpenseFunc.
func (mock *RepositoryMock) DeleteExpense(id string, uid string) error {
	if mock.DeleteExpenseFunc == nil {
		panic("RepositoryMock.DeleteExpenseFunc: method is nil but Repository.DeleteExpense was just called")
	}
	callInfo := struct {
		ID  string
		UID string
	}{
		ID:  id,
		UID: uid,
	}
	mock.lockDeleteExpense.Lock()
	mock.calls.DeleteExpense = append(mock.calls.DeleteExpense, callInfo)
	mock.lockDeleteExpense.Unlock()
	return mock.DeleteExpenseFunc(id, uid)
}

// DeleteExpenseCalls gets all the calls that were made to DeleteExpense.
// Check the length with:
//
//	len(mockedRepository.DeleteExpenseCalls())
func (mock *RepositoryMock) DeleteExpenseCalls() []struct {
	ID  string
	UID string
} {
	var calls []struct {
		ID  string
		UID string
	}
	mock.lockDeleteExpense.RLock()
	calls = mock.calls.DeleteExpense
	mock.lockDeleteExpense.RUnlock()
	return calls
}

// FindAllUIDs calls FindAllUIDsFunc.
func (mock *RepositoryMock) FindAllUIDs() ([]string, error) {
	if mock.FindAllUIDsFunc == nil {
		panic("RepositoryMock.FindAllUIDsFunc: method is nil but Repository.FindAllUIDs was just called")
	}
	callInfo := struct {
	}{}
	mock.lockFindAllUIDs.Lock()
	mock.calls.FindAllUIDs = append(mock.calls.FindAllUIDs, callInfo)
	mock.lockFindAllUIDs.Unlock()
	return mock.FindAllUIDsFunc()
}

// FindAllUIDsCalls gets all the calls that were made to FindAllUIDs.
// Check the length with:
//
//	len(mockedRepository.FindAllUIDsCalls())
func (mock *RepositoryMock) FindAllUIDsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFindAllUIDs.RLock()
	calls = mock.calls.FindAllUIDs
	mock.lockFindAllUIDs.RUnlock()
	return calls
}

// FindColumnChartExpenseData calls FindColumnChartExpenseDataFunc.
func (mock *RepositoryMock) FindColumnChartExpenseData(uid string) ([]repositories.ColumnChartData, error) {
	if mock.FindColumnChartExpenseDataFunc == nil {
		panic("RepositoryMock.FindColumnChartExpenseDataFunc: method is nil but Repository.FindColumnChartExpenseData was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockFindColumnChartExpenseData.Lock()
	mock.calls.FindColumnChartExpenseData = append(mock.calls.FindColumnChartExpenseData, callInfo)
	mock.lockFindColumnChartExpenseData.Unlock()
	return mock.FindColumnChartExpenseDataFunc(uid)
}

// FindColumnChartExpenseDataCalls gets all the calls that were made to FindColumnChartExpenseData.
// Check the length with:
//
//	len(mockedRepository.FindColumnChartExpenseDataCalls())
func (mock *RepositoryMock) FindColumnChartExpenseDataCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockFindColumnChartExpenseData.RLock()
	calls = mock.calls.FindColumnChartExpenseData
	mock.lockFindColumnChartExpenseData.RUnlock()
	return calls
}

// FindColumnChartIncomeData calls FindColumnChartIncomeDataFunc.
func (mock *RepositoryMock) FindColumnChartIncomeData(uid string) ([]repositories.ColumnChartData, error) {
	if mock.FindColumnChartIncomeDataFunc == nil {
		panic("RepositoryMock.FindColumnChartIncomeDataFunc: method is nil but Repository.FindColumnChartIncomeData was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockFindColumnChartIncomeData.Lock()
	mock.calls.FindColumnChartIncomeData = append(mock.calls.FindColumnChartIncomeData, callInfo)
	mock.lockFindColumnChartIncomeData.Unlock()
	return mock.FindColumnChartIncomeDataFunc(uid)
}

// FindColumnChartIncomeDataCalls gets all the calls that were made to FindColumnChartIncomeData.
// Check the length with:
//
//	len(mockedRepository.FindColumnChartIncomeDataCalls())
func (mock *RepositoryMock) FindColumnChartIncomeDataCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockFindColumnChartIncomeData.RLock()
	calls = mock.calls.FindColumnChartIncomeData
	mock.lockFindColumnChartIncomeData.RUnlock()
	return calls
}

// FindExpense calls FindExpenseFunc.
func (mock *RepositoryMock) FindExpense(id string, uid string) (model.Expense, error) {
	if mock.FindExpenseFunc == nil {
		panic("RepositoryMock.FindExpenseFunc: method is nil but Repository.FindExpense was just called")
	}
	callInfo := struct {
		ID  string
		UID string
	}{
		ID:  id,
		UID: uid,
	}
	mock.lockFindExpense.Lock()
	mock.calls.FindExpense = append(mock.calls.FindExpense, callInfo)
	mock.lockFindExpense.Unlock()
	return mock.FindExpenseFunc(id, uid)
}

// FindExpenseCalls gets all the calls that were made to FindExpense.
// Check the length with:
//
//	len(mockedRepository.FindExpenseCalls())
func (mock *RepositoryMock) FindExpenseCalls() []struct {
	ID  string
	UID string
} {
	var calls []struct {
		ID  string
		UID string
	}
	mock.lockFindExpense.RLock()
	calls = mock.calls.FindExpense
	mock.lockFindExpense.RUnlock()
	return calls
}

// FindExpenseCategories calls FindExpenseCategoriesFunc.
func (mock *RepositoryMock) FindExpenseCategories(uid string) ([]model.ExpenseCategory, error) {
	if mock.FindExpenseCategoriesFunc == nil {
		panic("RepositoryMock.FindExpenseCategoriesFunc: method is nil but Repository.FindExpenseCategories was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockFindExpenseCategories.Lock()
	mock.calls.FindExpenseCategories = append(mock.calls.FindExpenseCategories, callInfo)
	mock.lockFindExpenseCategories.Unlock()
	return mock.FindExpenseCategoriesFunc(uid)
}

// FindExpenseCategoriesCalls gets all the calls that were made to FindExpenseCategories.
// Check the length with:
//
//	len(mockedRepository.FindExpenseCategoriesCalls())
func (mock *RepositoryMock) FindExpenseCategoriesCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockFindExpenseCategories.RLock()
	calls = mock.calls.FindExpenseCategories
	mock.lockFindExpenseCategories.RUnlock()
	return calls
}

// FindExpenseCategory calls FindExpenseCategoryFunc.
func (mock *RepositoryMock) FindExpenseCategory(id string, uid string) (model.ExpenseCategory, error) {
	if mock.FindExpenseCategoryFunc == nil {
		panic("RepositoryMock.FindExpenseCategoryFunc: method is nil but Repository.FindExpenseCategory was just called")
	}
	callInfo := struct {
		ID  string
		UID string
	}{
		ID:  id,
		UID: uid,
	}
	mock.lockFindExpenseCategory.Lock()
	mock.calls.FindExpenseCategory = append(mock.calls.FindExpenseCategory, callInfo)
	mock.lockFindExpenseCategory.Unlock()
	return mock.FindExpenseCategoryFunc(id, uid)
}

// FindExpenseCategoryCalls gets all the calls that were made to FindExpenseCategory.
// Check the length with:
//
//	len(mockedRepository.FindExpenseCategoryCalls())
func (mock *RepositoryMock) FindExpenseCategoryCalls() []struct {
	ID  string
	UID string
} {
	var calls []struct {
		ID  string
		UID string
	}
	mock.lockFindExpenseCategory.RLock()
	calls = mock.calls.FindExpenseCategory
	mock.lockFindExpenseCategory.RUnlock()
	return calls
}

// FindExpenseLocation calls FindExpenseLocationFunc.
func (mock *RepositoryMock) FindExpenseLocation(id string, uid string) (model.ExpenseLocation, error) {
	if mock.FindExpenseLocationFunc == nil {
		panic("RepositoryMock.FindExpenseLocationFunc: method is nil but Repository.FindExpenseLocation was just called")
	}
	callInfo := struct {
		ID  string
		UID string
	}{
		ID:  id,
		UID: uid,
	}
	mock.lockFindExpenseLocation.Lock()
	mock.calls.FindExpenseLocation = append(mock.calls.FindExpenseLocation, callInfo)
	mock.lockFindExpenseLocation.Unlock()
	return mock.FindExpenseLocationFunc(id, uid)
}

// FindExpenseLocationCalls gets all the calls that were made to FindExpenseLocation.
// Check the length with:
//
//	len(mockedRepository.FindExpenseLocationCalls())
func (mock *RepositoryMock) FindExpenseLocationCalls() []struct {
	ID  string
	UID string
} {
	var calls []struct {
		ID  string
		UID string
	}
	mock.lockFindExpenseLocation.RLock()
	calls = mock.calls.FindExpenseLocation
	mock.lockFindExpenseLocation.RUnlock()
	return calls
}

// FindExpenseLocations calls FindExpenseLocationsFunc.
func (mock *RepositoryMock) FindExpenseLocations(uid string) ([]model.ExpenseLocation, error) {
	if mock.FindExpenseLocationsFunc == nil {
		panic("RepositoryMock.FindExpenseLocationsFunc: method is nil but Repository.FindExpenseLocations was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockFindExpenseLocations.Lock()
	mock.calls.FindExpenseLocations = append(mock.calls.FindExpenseLocations, callInfo)
	mock.lockFindExpenseLocations.Unlock()
	return mock.FindExpenseLocationsFunc(uid)
}

// FindExpenseLocationsCalls gets all the calls that were made to FindExpenseLocations.
// Check the length with:
//
//	len(mockedRepository.FindExpenseLocationsCalls())
func (mock *RepositoryMock) FindExpenseLocationsCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockFindExpenseLocations.RLock()
	calls = mock.calls.FindExpenseLocations
	mock.lockFindExpenseLocations.RUnlock()
	return calls
}

// FindExpenses calls FindExpensesFunc.
func (mock *RepositoryMock) FindExpenses(uid string, start *time.Time, end *time.Time) ([]model.Expense, error) {
	if mock.FindExpensesFunc == nil {
		panic("RepositoryMock.FindExpensesFunc: method is nil but Repository.FindExpenses was just called")
	}
	callInfo := struct {
		UID   string
		Start *time.Time
		End   *time.Time
	}{
		UID:   uid,
		Start: start,
		End:   end,
	}
	mock.lockFindExpenses.Lock()
	mock.calls.FindExpenses = append(mock.calls.FindExpenses, callInfo)
	mock.lockFindExpenses.Unlock()
	return mock.FindExpensesFunc(uid, start, end)
}

// FindExpensesCalls gets all the calls that were made to FindExpenses.
// Check the length with:
//
//	len(mockedRepository.FindExpensesCalls())
func (mock *RepositoryMock) FindExpensesCalls() []struct {
	UID   string
	Start *time.Time
	End   *time.Time
} {
	var calls []struct {
		UID   string
		Start *time.Time
		End   *time.Time
	}
	mock.lockFindExpenses.RLock()
	calls = mock.calls.FindExpenses
	mock.lockFindExpenses.RUnlock()
	return calls
}

// FindIncome calls FindIncomeFunc.
func (mock *RepositoryMock) FindIncome(id string, uid string) (model.Income, error) {
	if mock.FindIncomeFunc == nil {
		panic("RepositoryMock.FindIncomeFunc: method is nil but Repository.FindIncome was just called")
	}
	callInfo := struct {
		ID  string
		UID string
	}{
		ID:  id,
		UID: uid,
	}
	mock.lockFindIncome.Lock()
	mock.calls.FindIncome = append(mock.calls.FindIncome, callInfo)
	mock.lockFindIncome.Unlock()
	return mock.FindIncomeFunc(id, uid)
}

// FindIncomeCalls gets all the calls that were made to FindIncome.
// Check the length with:
//
//	len(mockedRepository.FindIncomeCalls())
func (mock *RepositoryMock) FindIncomeCalls() []struct {
	ID  string
	UID string
} {
	var calls []struct {
		ID  string
		UID string
	}
	mock.lockFindIncome.RLock()
	calls = mock.calls.FindIncome
	mock.lockFindIncome.RUnlock()
	return calls
}

// FindIncomeTypes calls FindIncomeTypesFunc.
func (mock *RepositoryMock) FindIncomeTypes(uid string) ([]model.IncomeType, error) {
	if mock.FindIncomeTypesFunc == nil {
		panic("RepositoryMock.FindIncomeTypesFunc: method is nil but Repository.FindIncomeTypes was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockFindIncomeTypes.Lock()
	mock.calls.FindIncomeTypes = append(mock.calls.FindIncomeTypes, callInfo)
	mock.lockFindIncomeTypes.Unlock()
	return mock.FindIncomeTypesFunc(uid)
}

// FindIncomeTypesCalls gets all the calls that were made to FindIncomeTypes.
// Check the length with:
//
//	len(mockedRepository.FindIncomeTypesCalls())
func (mock *RepositoryMock) FindIncomeTypesCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockFindIncomeTypes.RLock()
	calls = mock.calls.FindIncomeTypes
	mock.lockFindIncomeTypes.RUnlock()
	return calls
}

// FindIncomes calls FindIncomesFunc.
func (mock *RepositoryMock) FindIncomes(uid string, start *time.Time, end *time.Time) ([]model.Income, error) {
	if mock.FindIncomesFunc == nil {
		panic("RepositoryMock.FindIncomesFunc: method is nil but Repository.FindIncomes was just called")
	}
	callInfo := struct {
		UID   string
		Start *time.Time
		End   *time.Time
	}{
		UID:   uid,
		Start: start,
		End:   end,
	}
	mock.lockFindIncomes.Lock()
	mock.calls.FindIncomes = append(mock.calls.FindIncomes, callInfo)
	mock.lockFindIncomes.Unlock()
	return mock.FindIncomesFunc(uid, start, end)
}

// FindIncomesCalls gets all the calls that were made to FindIncomes.
// Check the length with:
//
//	len(mockedRepository.FindIncomesCalls())
func (mock *RepositoryMock) FindIncomesCalls() []struct {
	UID   string
	Start *time.Time
	End   *time.Time
} {
	var calls []struct {
		UID   string
		Start *time.Time
		End   *time.Time
	}
	mock.lockFindIncomes.RLock()
	calls = mock.calls.FindIncomes
	mock.lockFindIncomes.RUnlock()
	return calls
}

// FindOrCreateExpenseCategory calls FindOrCreateExpenseCategoryFunc.
func (mock *RepositoryMock) FindOrCreateExpenseCategory(uid string, name string) (model.ExpenseCategory, error) {
	if mock.FindOrCreateExpenseCategoryFunc == nil {
		panic("RepositoryMock.FindOrCreateExpenseCategoryFunc: method is nil but Repository.FindOrCreateExpenseCategory was just called")
	}
	callInfo := struct {
		UID  string
		Name string
	}{
		UID:  uid,
		Name: name,
	}
	mock.lockFindOrCreateExpenseCategory.Lock()
	mock.calls.FindOrCreateExpenseCategory = append(mock.calls.FindOrCreateExpenseCategory, callInfo)
	mock.lockFindOrCreateExpenseCategory.Unlock()
	return mock.FindOrCreateExpenseCategoryFunc(uid, name)
}

// FindOrCreateExpenseCategoryCalls gets all the calls that were made to FindOrCreateExpenseCategory.
// Check the length with:
//
//	len(mockedRepository.FindOrCreateExpenseCategoryCalls())
func (mock *RepositoryMock) FindOrCreateExpenseCategoryCalls() []struct {
	UID  string
	Name string
} {
	var calls []struct {
		UID  string
		Name string
	}
	mock.lockFindOrCreateExpenseCategory.RLock()
	calls = mock.calls.FindOrCreateExpenseCategory
	mock.lockFindOrCreateExpenseCategory.RUnlock()
	return calls
}

// FindOrCreateExpenseLocation calls FindOrCreateExpenseLocationFunc.
func (mock *RepositoryMock) FindOrCreateExpenseLocation(uid string, name string) (model.ExpenseLocation, error) {
	if mock.FindOrCreateExpenseLocationFunc == nil {
		panic("RepositoryMock.FindOrCreateExpenseLocationFunc: method is nil but Repository.FindOrCreateExpenseLocation was just called")
	}
	callInfo := struct {
		UID  string
		Name string
	}{
		UID:  uid,
		Name: name,
	}
	mock.lockFindOrCreateExpenseLocation.Lock()
	mock.calls.FindOrCreateExpenseLocation = append(mock.calls.FindOrCreateExpenseLocation, callInfo)
	mock.lockFindOrCreateExpenseLocation.Unlock()
	return mock.FindOrCreateExpenseLocationFunc(uid, name)
}

// FindOrCreateExpenseLocationCalls gets all the calls that were made to FindOrCreateExpenseLocation.
// Check the length with:
//
//	len(mockedRepository.FindOrCreateExpenseLocationCalls())
func (mock *RepositoryMock) FindOrCreateExpenseLocationCalls() []struct {
	UID  string
	Name string
} {
	var calls []struct {
		UID  string
		Name string
	}
	mock.lockFindOrCreateExpenseLocation.RLock()
	calls = mock.calls.FindOrCreateExpenseLocation
	mock.lockFindOrCreateExpenseLocation.RUnlock()
	return calls
}

// FindOrCreateIncomeType calls FindOrCreateIncomeTypeFunc.
func (mock *RepositoryMock) FindOrCreateIncomeType(uid string, name string) (model.IncomeType, error) {
	if mock.FindOrCreateIncomeTypeFunc == nil {
		panic("RepositoryMock.FindOrCreateIncomeTypeFunc: method is nil but Repository.FindOrCreateIncomeType was just called")
	}
	callInfo := struct {
		UID  string
		Name string
	}{
		UID:  uid,
		Name: name,
	}
	mock.lockFindOrCreateIncomeType.Lock()
	mock.calls.FindOrCreateIncomeType = append(mock.calls.FindOrCreateIncomeType, callInfo)
	mock.lockFindOrCreateIncomeType.Unlock()
	return mock.FindOrCreateIncomeTypeFunc(uid, name)
}

// FindOrCreateIncomeTypeCalls gets all the calls that were made to FindOrCreateIncomeType.
// Check the length with:
//
//	len(mockedRepository.FindOrCreateIncomeTypeCalls())
func (mock *RepositoryMock) FindOrCreateIncomeTypeCalls() []struct {
	UID  string
	Name string
} {
	var calls []struct {
		UID  string
		Name string
	}
	mock.lockFindOrCreateIncomeType.RLock()
	calls = mock.calls.FindOrCreateIncomeType
	mock.lockFindOrCreateIncomeType.RUnlock()
	return calls
}

// FindOrCreateUser calls FindOrCreateUserFunc.
func (mock *RepositoryMock) FindOrCreateUser(uid string) (model.User, error) {
	if mock.FindOrCreateUserFunc == nil {
		panic("RepositoryMock.FindOrCreateUserFunc: method is nil but Repository.FindOrCreateUser was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockFindOrCreateUser.Lock()
	mock.calls.FindOrCreateUser = append(mock.calls.FindOrCreateUser, callInfo)
	mock.lockFindOrCreateUser.Unlock()
	return mock.FindOrCreateUserFunc(uid)
}

// FindOrCreateUserCalls gets all the calls that were made to FindOrCreateUser.
// Check the length with:
//
//	len(mockedRepository.FindOrCreateUserCalls())
func (mock *RepositoryMock) FindOrCreateUserCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockFindOrCreateUser.RLock()
	calls = mock.calls.FindOrCreateUser
	mock.lockFindOrCreateUser.RUnlock()
	return calls
}

// FindTransactionMonths calls FindTransactionMonthsFunc.
func (mock *RepositoryMock) FindTransactionMonths(uid string) ([]string, error) {
	if mock.FindTransactionMonthsFunc == nil {
		panic("RepositoryMock.FindTransactionMonthsFunc: method is nil but Repository.FindTransactionMonths was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockFindTransactionMonths.Lock()
	mock.calls.FindTransactionMonths = append(mock.calls.FindTransactionMonths, callInfo)
	mock.lockFindTransactionMonths.Unlock()
	return mock.FindTransactionMonthsFunc(uid)
}

// FindTransactionMonthsCalls gets all the calls that were made to FindTransactionMonths.
// Check the length with:
//
//	len(mockedRepository.FindTransactionMonthsCalls())
func (mock *RepositoryMock) FindTransactionMonthsCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockFindTransactionMonths.RLock()
	calls = mock.calls.FindTransactionMonths
	mock.lockFindTransactionMonths.RUnlock()
	return calls
}

// HardDeleteAllUserExpenseCategories calls HardDeleteAllUserExpenseCategoriesFunc.
func (mock *RepositoryMock) HardDeleteAllUserExpenseCategories(uid string) error {
	if mock.HardDeleteAllUserExpenseCategoriesFunc == nil {
		panic("RepositoryMock.HardDeleteAllUserExpenseCategoriesFunc: method is nil but Repository.HardDeleteAllUserExpenseCategories was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockHardDeleteAllUserExpenseCategories.Lock()
	mock.calls.HardDeleteAllUserExpenseCategories = append(mock.calls.HardDeleteAllUserExpenseCategories, callInfo)
	mock.lockHardDeleteAllUserExpenseCategories.Unlock()
	return mock.HardDeleteAllUserExpenseCategoriesFunc(uid)
}

// HardDeleteAllUserExpenseCategoriesCalls gets all the calls that were made to HardDeleteAllUserExpenseCategories.
// Check the length with:
//
//	len(mockedRepository.HardDeleteAllUserExpenseCategoriesCalls())
func (mock *RepositoryMock) HardDeleteAllUserExpenseCategoriesCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockHardDeleteAllUserExpenseCategories.RLock()
	calls = mock.calls.HardDeleteAllUserExpenseCategories
	mock.lockHardDeleteAllUserExpenseCategories.RUnlock()
	return calls
}

// HardDeleteAllUserExpenseLocations calls HardDeleteAllUserExpenseLocationsFunc.
func (mock *RepositoryMock) HardDeleteAllUserExpenseLocations(uid string) error {
	if mock.HardDeleteAllUserExpenseLocationsFunc == nil {
		panic("RepositoryMock.HardDeleteAllUserExpenseLocationsFunc: method is nil but Repository.HardDeleteAllUserExpenseLocations was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockHardDeleteAllUserExpenseLocations.Lock()
	mock.calls.HardDeleteAllUserExpenseLocations = append(mock.calls.HardDeleteAllUserExpenseLocations, callInfo)
	mock.lockHardDeleteAllUserExpenseLocations.Unlock()
	return mock.HardDeleteAllUserExpenseLocationsFunc(uid)
}

// HardDeleteAllUserExpenseLocationsCalls gets all the calls that were made to HardDeleteAllUserExpenseLocations.
// Check the length with:
//
//	len(mockedRepository.HardDeleteAllUserExpenseLocationsCalls())
func (mock *RepositoryMock) HardDeleteAllUserExpenseLocationsCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockHardDeleteAllUserExpenseLocations.RLock()
	calls = mock.calls.HardDeleteAllUserExpenseLocations
	mock.lockHardDeleteAllUserExpenseLocations.RUnlock()
	return calls
}

// HardDeleteAllUserExpenses calls HardDeleteAllUserExpensesFunc.
func (mock *RepositoryMock) HardDeleteAllUserExpenses(uid string) error {
	if mock.HardDeleteAllUserExpensesFunc == nil {
		panic("RepositoryMock.HardDeleteAllUserExpensesFunc: method is nil but Repository.HardDeleteAllUserExpenses was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockHardDeleteAllUserExpenses.Lock()
	mock.calls.HardDeleteAllUserExpenses = append(mock.calls.HardDeleteAllUserExpenses, callInfo)
	mock.lockHardDeleteAllUserExpenses.Unlock()
	return mock.HardDeleteAllUserExpensesFunc(uid)
}

// HardDeleteAllUserExpensesCalls gets all the calls that were made to HardDeleteAllUserExpenses.
// Check the length with:
//
//	len(mockedRepository.HardDeleteAllUserExpensesCalls())
func (mock *RepositoryMock) HardDeleteAllUserExpensesCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockHardDeleteAllUserExpenses.RLock()
	calls = mock.calls.HardDeleteAllUserExpenses
	mock.lockHardDeleteAllUserExpenses.RUnlock()
	return calls
}

// HardDeleteAllUserIncomes calls HardDeleteAllUserIncomesFunc.
func (mock *RepositoryMock) HardDeleteAllUserIncomes(uid string) error {
	if mock.HardDeleteAllUserIncomesFunc == nil {
		panic("RepositoryMock.HardDeleteAllUserIncomesFunc: method is nil but Repository.HardDeleteAllUserIncomes was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockHardDeleteAllUserIncomes.Lock()
	mock.calls.HardDeleteAllUserIncomes = append(mock.calls.HardDeleteAllUserIncomes, callInfo)
	mock.lockHardDeleteAllUserIncomes.Unlock()
	return mock.HardDeleteAllUserIncomesFunc(uid)
}

// HardDeleteAllUserIncomesCalls gets all the calls that were made to HardDeleteAllUserIncomes.
// Check the length with:
//
//	len(mockedRepository.HardDeleteAllUserIncomesCalls())
func (mock *RepositoryMock) HardDeleteAllUserIncomesCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockHardDeleteAllUserIncomes.RLock()
	calls = mock.calls.HardDeleteAllUserIncomes
	mock.lockHardDeleteAllUserIncomes.RUnlock()
	return calls
}

// Transaction calls TransactionFunc.
func (mock *RepositoryMock) Transaction(fc func(txRepo *repositories.SuitoRepository) error, opts ...*sql.TxOptions) error {
	if mock.TransactionFunc == nil {
		panic("RepositoryMock.TransactionFunc: method is nil but Repository.Transaction was just called")
	}
	callInfo := struct {
		Fc   func(txRepo *repositories.SuitoRepository) error
		Opts []*sql.TxOptions
	}{
		Fc:   fc,
		Opts: opts,
	}
	mock.lockTransaction.Lock()
	mock.calls.Transaction = append(mock.calls.Transaction, callInfo)
	mock.lockTransaction.Unlock()
	return mock.TransactionFunc(fc, opts...)
}

// TransactionCalls gets all the calls that were made to Transaction.
// Check the length with:
//
//	len(mockedRepository.TransactionCalls())
func (mock *RepositoryMock) TransactionCalls() []struct {
	Fc   func(txRepo *repositories.SuitoRepository) error
	Opts []*sql.TxOptions
} {
	var calls []struct {
		Fc   func(txRepo *repositories.SuitoRepository) error
		Opts []*sql.TxOptions
	}
	mock.lockTransaction.RLock()
	calls = mock.calls.Transaction
	mock.lockTransaction.RUnlock()
	return calls
}

// UpdateExpense calls UpdateExpenseFunc.
func (mock *RepositoryMock) UpdateExpense(uid string, expense model.Expense) (model.Expense, error) {
	if mock.UpdateExpenseFunc == nil {
		panic("RepositoryMock.UpdateExpenseFunc: method is nil but Repository.UpdateExpense was just called")
	}
	callInfo := struct {
		UID     string
		Expense model.Expense
	}{
		UID:     uid,
		Expense: expense,
	}
	mock.lockUpdateExpense.Lock()
	mock.calls.UpdateExpense = append(mock.calls.UpdateExpense, callInfo)
	mock.lockUpdateExpense.Unlock()
	return mock.UpdateExpenseFunc(uid, expense)
}

// UpdateExpenseCalls gets all the calls that were made to UpdateExpense.
// Check the length with:
//
//	len(mockedRepository.UpdateExpenseCalls())
func (mock *RepositoryMock) UpdateExpenseCalls() []struct {
	UID     string
	Expense model.Expense
} {
	var calls []struct {
		UID     string
		Expense model.Expense
	}
	mock.lockUpdateExpense.RLock()
	calls = mock.calls.UpdateExpense
	mock.lockUpdateExpense.RUnlock()
	return calls
}
