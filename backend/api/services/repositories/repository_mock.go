// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package repositories

import (
	"database/sql"
	"github.com/wakamenod/suito/api/repositories"
	"github.com/wakamenod/suito/model"
	"sync"
	"time"
)

// Ensure, that RepositoryMock does implement Repository.
// If this is not the case, regenerate this file with moq.
var _ Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of Repository.
//
//	func TestSomethingThatUsesRepository(t *testing.T) {
//
//		// make and configure a mocked Repository
//		mockedRepository := &RepositoryMock{
//			CreateExpenseFunc: func(uid string, expense model.Expense) (model.Expense, error) {
//				panic("mock out the CreateExpense method")
//			},
//			CreateIncomeFunc: func(uid string, income model.Income) (model.Income, error) {
//				panic("mock out the CreateIncome method")
//			},
//			DeleteExpenseFunc: func(id string, uid string) error {
//				panic("mock out the DeleteExpense method")
//			},
//			DeleteExpenseScheduleFunc: func(id string, uid string) error {
//				panic("mock out the DeleteExpenseSchedule method")
//			},
//			DeleteIncomeScheduleFunc: func(id string, uid string) error {
//				panic("mock out the DeleteIncomeSchedule method")
//			},
//			FindAllUIDsFunc: func() ([]string, error) {
//				panic("mock out the FindAllUIDs method")
//			},
//			FindColumnChartExpenseDataFunc: func(uid string) ([]repositories.ColumnChartData, error) {
//				panic("mock out the FindColumnChartExpenseData method")
//			},
//			FindColumnChartIncomeDataFunc: func(uid string) ([]repositories.ColumnChartData, error) {
//				panic("mock out the FindColumnChartIncomeData method")
//			},
//			FindExpenseFunc: func(id string, uid string) (model.Expense, error) {
//				panic("mock out the FindExpense method")
//			},
//			FindExpenseCategoriesFunc: func(uid string) ([]model.ExpenseCategory, error) {
//				panic("mock out the FindExpenseCategories method")
//			},
//			FindExpenseCategoryFunc: func(id string, uid string) (model.ExpenseCategory, error) {
//				panic("mock out the FindExpenseCategory method")
//			},
//			FindExpenseLocationFunc: func(id string, uid string) (model.ExpenseLocation, error) {
//				panic("mock out the FindExpenseLocation method")
//			},
//			FindExpenseLocationsFunc: func(uid string) ([]model.ExpenseLocation, error) {
//				panic("mock out the FindExpenseLocations method")
//			},
//			FindExpenseScheduleFunc: func(id string, uid string) (model.ExpenseSchedule, error) {
//				panic("mock out the FindExpenseSchedule method")
//			},
//			FindExpenseSchedulesFunc: func(uid string) ([]model.ExpenseSchedule, error) {
//				panic("mock out the FindExpenseSchedules method")
//			},
//			FindExpensesFunc: func(uid string, start *time.Time, end *time.Time) ([]model.Expense, error) {
//				panic("mock out the FindExpenses method")
//			},
//			FindIncomeFunc: func(id string, uid string) (model.Income, error) {
//				panic("mock out the FindIncome method")
//			},
//			FindIncomeScheduleFunc: func(id string, uid string) (model.IncomeSchedule, error) {
//				panic("mock out the FindIncomeSchedule method")
//			},
//			FindIncomeSchedulesFunc: func(uid string) ([]model.IncomeSchedule, error) {
//				panic("mock out the FindIncomeSchedules method")
//			},
//			FindIncomeTypesFunc: func(uid string) ([]model.IncomeType, error) {
//				panic("mock out the FindIncomeTypes method")
//			},
//			FindIncomesFunc: func(uid string, start *time.Time, end *time.Time) ([]model.Income, error) {
//				panic("mock out the FindIncomes method")
//			},
//			FindOrCreateExpenseCategoryFunc: func(uid string, name string) (model.ExpenseCategory, error) {
//				panic("mock out the FindOrCreateExpenseCategory method")
//			},
//			FindOrCreateExpenseLocationFunc: func(uid string, name string) (model.ExpenseLocation, error) {
//				panic("mock out the FindOrCreateExpenseLocation method")
//			},
//			FindOrCreateIncomeTypeFunc: func(uid string, name string) (model.IncomeType, error) {
//				panic("mock out the FindOrCreateIncomeType method")
//			},
//			FindOrCreateUserFunc: func(uid string) (model.User, error) {
//				panic("mock out the FindOrCreateUser method")
//			},
//			FindPieChartCategoryDataFunc: func(uid string, start *time.Time, end *time.Time) ([]repositories.PieChartData, error) {
//				panic("mock out the FindPieChartCategoryData method")
//			},
//			FindPieChartLocationDataFunc: func(uid string, start *time.Time, end *time.Time) ([]repositories.PieChartData, error) {
//				panic("mock out the FindPieChartLocationData method")
//			},
//			FindTransactionMonthsFunc: func(uid string) ([]string, error) {
//				panic("mock out the FindTransactionMonths method")
//			},
//			HardDeleteAllUserExpenseCategoriesFunc: func(uid string) error {
//				panic("mock out the HardDeleteAllUserExpenseCategories method")
//			},
//			HardDeleteAllUserExpenseLocationsFunc: func(uid string) error {
//				panic("mock out the HardDeleteAllUserExpenseLocations method")
//			},
//			HardDeleteAllUserExpensesFunc: func(uid string) error {
//				panic("mock out the HardDeleteAllUserExpenses method")
//			},
//			HardDeleteAllUserIncomesFunc: func(uid string) error {
//				panic("mock out the HardDeleteAllUserIncomes method")
//			},
//			TransactionFunc: func(fc func(txRepo *repositories.SuitoRepository) error, opts ...*sql.TxOptions) error {
//				panic("mock out the Transaction method")
//			},
//			UpdateExpenseFunc: func(uid string, expense model.Expense) (model.Expense, error) {
//				panic("mock out the UpdateExpense method")
//			},
//			UpdateExpenseScheduleFunc: func(uid string, schedule model.ExpenseSchedule) (model.ExpenseSchedule, error) {
//				panic("mock out the UpdateExpenseSchedule method")
//			},
//			UpdateIncomeFunc: func(uid string, income model.Income) (model.Income, error) {
//				panic("mock out the UpdateIncome method")
//			},
//			UpdateIncomeScheduleFunc: func(uid string, schedule model.IncomeSchedule) (model.IncomeSchedule, error) {
//				panic("mock out the UpdateIncomeSchedule method")
//			},
//		}
//
//		// use mockedRepository in code that requires Repository
//		// and then make assertions.
//
//	}
type RepositoryMock struct {
	// CreateExpenseFunc mocks the CreateExpense method.
	CreateExpenseFunc func(uid string, expense model.Expense) (model.Expense, error)

	// CreateIncomeFunc mocks the CreateIncome method.
	CreateIncomeFunc func(uid string, income model.Income) (model.Income, error)

	// DeleteExpenseFunc mocks the DeleteExpense method.
	DeleteExpenseFunc func(id string, uid string) error

	// DeleteExpenseScheduleFunc mocks the DeleteExpenseSchedule method.
	DeleteExpenseScheduleFunc func(id string, uid string) error

	// DeleteIncomeScheduleFunc mocks the DeleteIncomeSchedule method.
	DeleteIncomeScheduleFunc func(id string, uid string) error

	// FindAllUIDsFunc mocks the FindAllUIDs method.
	FindAllUIDsFunc func() ([]string, error)

	// FindColumnChartExpenseDataFunc mocks the FindColumnChartExpenseData method.
	FindColumnChartExpenseDataFunc func(uid string) ([]repositories.ColumnChartData, error)

	// FindColumnChartIncomeDataFunc mocks the FindColumnChartIncomeData method.
	FindColumnChartIncomeDataFunc func(uid string) ([]repositories.ColumnChartData, error)

	// FindExpenseFunc mocks the FindExpense method.
	FindExpenseFunc func(id string, uid string) (model.Expense, error)

	// FindExpenseCategoriesFunc mocks the FindExpenseCategories method.
	FindExpenseCategoriesFunc func(uid string) ([]model.ExpenseCategory, error)

	// FindExpenseCategoryFunc mocks the FindExpenseCategory method.
	FindExpenseCategoryFunc func(id string, uid string) (model.ExpenseCategory, error)

	// FindExpenseLocationFunc mocks the FindExpenseLocation method.
	FindExpenseLocationFunc func(id string, uid string) (model.ExpenseLocation, error)

	// FindExpenseLocationsFunc mocks the FindExpenseLocations method.
	FindExpenseLocationsFunc func(uid string) ([]model.ExpenseLocation, error)

	// FindExpenseScheduleFunc mocks the FindExpenseSchedule method.
	FindExpenseScheduleFunc func(id string, uid string) (model.ExpenseSchedule, error)

	// FindExpenseSchedulesFunc mocks the FindExpenseSchedules method.
	FindExpenseSchedulesFunc func(uid string) ([]model.ExpenseSchedule, error)

	// FindExpensesFunc mocks the FindExpenses method.
	FindExpensesFunc func(uid string, start *time.Time, end *time.Time) ([]model.Expense, error)

	// FindIncomeFunc mocks the FindIncome method.
	FindIncomeFunc func(id string, uid string) (model.Income, error)

	// FindIncomeScheduleFunc mocks the FindIncomeSchedule method.
	FindIncomeScheduleFunc func(id string, uid string) (model.IncomeSchedule, error)

	// FindIncomeSchedulesFunc mocks the FindIncomeSchedules method.
	FindIncomeSchedulesFunc func(uid string) ([]model.IncomeSchedule, error)

	// FindIncomeTypesFunc mocks the FindIncomeTypes method.
	FindIncomeTypesFunc func(uid string) ([]model.IncomeType, error)

	// FindIncomesFunc mocks the FindIncomes method.
	FindIncomesFunc func(uid string, start *time.Time, end *time.Time) ([]model.Income, error)

	// FindOrCreateExpenseCategoryFunc mocks the FindOrCreateExpenseCategory method.
	FindOrCreateExpenseCategoryFunc func(uid string, name string) (model.ExpenseCategory, error)

	// FindOrCreateExpenseLocationFunc mocks the FindOrCreateExpenseLocation method.
	FindOrCreateExpenseLocationFunc func(uid string, name string) (model.ExpenseLocation, error)

	// FindOrCreateIncomeTypeFunc mocks the FindOrCreateIncomeType method.
	FindOrCreateIncomeTypeFunc func(uid string, name string) (model.IncomeType, error)

	// FindOrCreateUserFunc mocks the FindOrCreateUser method.
	FindOrCreateUserFunc func(uid string) (model.User, error)

	// FindPieChartCategoryDataFunc mocks the FindPieChartCategoryData method.
	FindPieChartCategoryDataFunc func(uid string, start *time.Time, end *time.Time) ([]repositories.PieChartData, error)

	// FindPieChartLocationDataFunc mocks the FindPieChartLocationData method.
	FindPieChartLocationDataFunc func(uid string, start *time.Time, end *time.Time) ([]repositories.PieChartData, error)

	// FindTransactionMonthsFunc mocks the FindTransactionMonths method.
	FindTransactionMonthsFunc func(uid string) ([]string, error)

	// HardDeleteAllUserExpenseCategoriesFunc mocks the HardDeleteAllUserExpenseCategories method.
	HardDeleteAllUserExpenseCategoriesFunc func(uid string) error

	// HardDeleteAllUserExpenseLocationsFunc mocks the HardDeleteAllUserExpenseLocations method.
	HardDeleteAllUserExpenseLocationsFunc func(uid string) error

	// HardDeleteAllUserExpensesFunc mocks the HardDeleteAllUserExpenses method.
	HardDeleteAllUserExpensesFunc func(uid string) error

	// HardDeleteAllUserIncomesFunc mocks the HardDeleteAllUserIncomes method.
	HardDeleteAllUserIncomesFunc func(uid string) error

	// TransactionFunc mocks the Transaction method.
	TransactionFunc func(fc func(txRepo *repositories.SuitoRepository) error, opts ...*sql.TxOptions) error

	// UpdateExpenseFunc mocks the UpdateExpense method.
	UpdateExpenseFunc func(uid string, expense model.Expense) (model.Expense, error)

	// UpdateExpenseScheduleFunc mocks the UpdateExpenseSchedule method.
	UpdateExpenseScheduleFunc func(uid string, schedule model.ExpenseSchedule) (model.ExpenseSchedule, error)

	// UpdateIncomeFunc mocks the UpdateIncome method.
	UpdateIncomeFunc func(uid string, income model.Income) (model.Income, error)

	// UpdateIncomeScheduleFunc mocks the UpdateIncomeSchedule method.
	UpdateIncomeScheduleFunc func(uid string, schedule model.IncomeSchedule) (model.IncomeSchedule, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateExpense holds details about calls to the CreateExpense method.
		CreateExpense []struct {
			// UID is the uid argument value.
			UID string
			// Expense is the expense argument value.
			Expense model.Expense
		}
		// CreateIncome holds details about calls to the CreateIncome method.
		CreateIncome []struct {
			// UID is the uid argument value.
			UID string
			// Income is the income argument value.
			Income model.Income
		}
		// DeleteExpense holds details about calls to the DeleteExpense method.
		DeleteExpense []struct {
			// ID is the id argument value.
			ID string
			// UID is the uid argument value.
			UID string
		}
		// DeleteExpenseSchedule holds details about calls to the DeleteExpenseSchedule method.
		DeleteExpenseSchedule []struct {
			// ID is the id argument value.
			ID string
			// UID is the uid argument value.
			UID string
		}
		// DeleteIncomeSchedule holds details about calls to the DeleteIncomeSchedule method.
		DeleteIncomeSchedule []struct {
			// ID is the id argument value.
			ID string
			// UID is the uid argument value.
			UID string
		}
		// FindAllUIDs holds details about calls to the FindAllUIDs method.
		FindAllUIDs []struct {
		}
		// FindColumnChartExpenseData holds details about calls to the FindColumnChartExpenseData method.
		FindColumnChartExpenseData []struct {
			// UID is the uid argument value.
			UID string
		}
		// FindColumnChartIncomeData holds details about calls to the FindColumnChartIncomeData method.
		FindColumnChartIncomeData []struct {
			// UID is the uid argument value.
			UID string
		}
		// FindExpense holds details about calls to the FindExpense method.
		FindExpense []struct {
			// ID is the id argument value.
			ID string
			// UID is the uid argument value.
			UID string
		}
		// FindExpenseCategories holds details about calls to the FindExpenseCategories method.
		FindExpenseCategories []struct {
			// UID is the uid argument value.
			UID string
		}
		// FindExpenseCategory holds details about calls to the FindExpenseCategory method.
		FindExpenseCategory []struct {
			// ID is the id argument value.
			ID string
			// UID is the uid argument value.
			UID string
		}
		// FindExpenseLocation holds details about calls to the FindExpenseLocation method.
		FindExpenseLocation []struct {
			// ID is the id argument value.
			ID string
			// UID is the uid argument value.
			UID string
		}
		// FindExpenseLocations holds details about calls to the FindExpenseLocations method.
		FindExpenseLocations []struct {
			// UID is the uid argument value.
			UID string
		}
		// FindExpenseSchedule holds details about calls to the FindExpenseSchedule method.
		FindExpenseSchedule []struct {
			// ID is the id argument value.
			ID string
			// UID is the uid argument value.
			UID string
		}
		// FindExpenseSchedules holds details about calls to the FindExpenseSchedules method.
		FindExpenseSchedules []struct {
			// UID is the uid argument value.
			UID string
		}
		// FindExpenses holds details about calls to the FindExpenses method.
		FindExpenses []struct {
			// UID is the uid argument value.
			UID string
			// Start is the start argument value.
			Start *time.Time
			// End is the end argument value.
			End *time.Time
		}
		// FindIncome holds details about calls to the FindIncome method.
		FindIncome []struct {
			// ID is the id argument value.
			ID string
			// UID is the uid argument value.
			UID string
		}
		// FindIncomeSchedule holds details about calls to the FindIncomeSchedule method.
		FindIncomeSchedule []struct {
			// ID is the id argument value.
			ID string
			// UID is the uid argument value.
			UID string
		}
		// FindIncomeSchedules holds details about calls to the FindIncomeSchedules method.
		FindIncomeSchedules []struct {
			// UID is the uid argument value.
			UID string
		}
		// FindIncomeTypes holds details about calls to the FindIncomeTypes method.
		FindIncomeTypes []struct {
			// UID is the uid argument value.
			UID string
		}
		// FindIncomes holds details about calls to the FindIncomes method.
		FindIncomes []struct {
			// UID is the uid argument value.
			UID string
			// Start is the start argument value.
			Start *time.Time
			// End is the end argument value.
			End *time.Time
		}
		// FindOrCreateExpenseCategory holds details about calls to the FindOrCreateExpenseCategory method.
		FindOrCreateExpenseCategory []struct {
			// UID is the uid argument value.
			UID string
			// Name is the name argument value.
			Name string
		}
		// FindOrCreateExpenseLocation holds details about calls to the FindOrCreateExpenseLocation method.
		FindOrCreateExpenseLocation []struct {
			// UID is the uid argument value.
			UID string
			// Name is the name argument value.
			Name string
		}
		// FindOrCreateIncomeType holds details about calls to the FindOrCreateIncomeType method.
		FindOrCreateIncomeType []struct {
			// UID is the uid argument value.
			UID string
			// Name is the name argument value.
			Name string
		}
		// FindOrCreateUser holds details about calls to the FindOrCreateUser method.
		FindOrCreateUser []struct {
			// UID is the uid argument value.
			UID string
		}
		// FindPieChartCategoryData holds details about calls to the FindPieChartCategoryData method.
		FindPieChartCategoryData []struct {
			// UID is the uid argument value.
			UID string
			// Start is the start argument value.
			Start *time.Time
			// End is the end argument value.
			End *time.Time
		}
		// FindPieChartLocationData holds details about calls to the FindPieChartLocationData method.
		FindPieChartLocationData []struct {
			// UID is the uid argument value.
			UID string
			// Start is the start argument value.
			Start *time.Time
			// End is the end argument value.
			End *time.Time
		}
		// FindTransactionMonths holds details about calls to the FindTransactionMonths method.
		FindTransactionMonths []struct {
			// UID is the uid argument value.
			UID string
		}
		// HardDeleteAllUserExpenseCategories holds details about calls to the HardDeleteAllUserExpenseCategories method.
		HardDeleteAllUserExpenseCategories []struct {
			// UID is the uid argument value.
			UID string
		}
		// HardDeleteAllUserExpenseLocations holds details about calls to the HardDeleteAllUserExpenseLocations method.
		HardDeleteAllUserExpenseLocations []struct {
			// UID is the uid argument value.
			UID string
		}
		// HardDeleteAllUserExpenses holds details about calls to the HardDeleteAllUserExpenses method.
		HardDeleteAllUserExpenses []struct {
			// UID is the uid argument value.
			UID string
		}
		// HardDeleteAllUserIncomes holds details about calls to the HardDeleteAllUserIncomes method.
		HardDeleteAllUserIncomes []struct {
			// UID is the uid argument value.
			UID string
		}
		// Transaction holds details about calls to the Transaction method.
		Transaction []struct {
			// Fc is the fc argument value.
			Fc func(txRepo *repositories.SuitoRepository) error
			// Opts is the opts argument value.
			Opts []*sql.TxOptions
		}
		// UpdateExpense holds details about calls to the UpdateExpense method.
		UpdateExpense []struct {
			// UID is the uid argument value.
			UID string
			// Expense is the expense argument value.
			Expense model.Expense
		}
		// UpdateExpenseSchedule holds details about calls to the UpdateExpenseSchedule method.
		UpdateExpenseSchedule []struct {
			// UID is the uid argument value.
			UID string
			// Schedule is the schedule argument value.
			Schedule model.ExpenseSchedule
		}
		// UpdateIncome holds details about calls to the UpdateIncome method.
		UpdateIncome []struct {
			// UID is the uid argument value.
			UID string
			// Income is the income argument value.
			Income model.Income
		}
		// UpdateIncomeSchedule holds details about calls to the UpdateIncomeSchedule method.
		UpdateIncomeSchedule []struct {
			// UID is the uid argument value.
			UID string
			// Schedule is the schedule argument value.
			Schedule model.IncomeSchedule
		}
	}
	lockCreateExpense                      sync.RWMutex
	lockCreateIncome                       sync.RWMutex
	lockDeleteExpense                      sync.RWMutex
	lockDeleteExpenseSchedule              sync.RWMutex
	lockDeleteIncomeSchedule               sync.RWMutex
	lockFindAllUIDs                        sync.RWMutex
	lockFindColumnChartExpenseData         sync.RWMutex
	lockFindColumnChartIncomeData          sync.RWMutex
	lockFindExpense                        sync.RWMutex
	lockFindExpenseCategories              sync.RWMutex
	lockFindExpenseCategory                sync.RWMutex
	lockFindExpenseLocation                sync.RWMutex
	lockFindExpenseLocations               sync.RWMutex
	lockFindExpenseSchedule                sync.RWMutex
	lockFindExpenseSchedules               sync.RWMutex
	lockFindExpenses                       sync.RWMutex
	lockFindIncome                         sync.RWMutex
	lockFindIncomeSchedule                 sync.RWMutex
	lockFindIncomeSchedules                sync.RWMutex
	lockFindIncomeTypes                    sync.RWMutex
	lockFindIncomes                        sync.RWMutex
	lockFindOrCreateExpenseCategory        sync.RWMutex
	lockFindOrCreateExpenseLocation        sync.RWMutex
	lockFindOrCreateIncomeType             sync.RWMutex
	lockFindOrCreateUser                   sync.RWMutex
	lockFindPieChartCategoryData           sync.RWMutex
	lockFindPieChartLocationData           sync.RWMutex
	lockFindTransactionMonths              sync.RWMutex
	lockHardDeleteAllUserExpenseCategories sync.RWMutex
	lockHardDeleteAllUserExpenseLocations  sync.RWMutex
	lockHardDeleteAllUserExpenses          sync.RWMutex
	lockHardDeleteAllUserIncomes           sync.RWMutex
	lockTransaction                        sync.RWMutex
	lockUpdateExpense                      sync.RWMutex
	lockUpdateExpenseSchedule              sync.RWMutex
	lockUpdateIncome                       sync.RWMutex
	lockUpdateIncomeSchedule               sync.RWMutex
}

// CreateExpense calls CreateExpenseFunc.
func (mock *RepositoryMock) CreateExpense(uid string, expense model.Expense) (model.Expense, error) {
	if mock.CreateExpenseFunc == nil {
		panic("RepositoryMock.CreateExpenseFunc: method is nil but Repository.CreateExpense was just called")
	}
	callInfo := struct {
		UID     string
		Expense model.Expense
	}{
		UID:     uid,
		Expense: expense,
	}
	mock.lockCreateExpense.Lock()
	mock.calls.CreateExpense = append(mock.calls.CreateExpense, callInfo)
	mock.lockCreateExpense.Unlock()
	return mock.CreateExpenseFunc(uid, expense)
}

// CreateExpenseCalls gets all the calls that were made to CreateExpense.
// Check the length with:
//
//	len(mockedRepository.CreateExpenseCalls())
func (mock *RepositoryMock) CreateExpenseCalls() []struct {
	UID     string
	Expense model.Expense
} {
	var calls []struct {
		UID     string
		Expense model.Expense
	}
	mock.lockCreateExpense.RLock()
	calls = mock.calls.CreateExpense
	mock.lockCreateExpense.RUnlock()
	return calls
}

// CreateIncome calls CreateIncomeFunc.
func (mock *RepositoryMock) CreateIncome(uid string, income model.Income) (model.Income, error) {
	if mock.CreateIncomeFunc == nil {
		panic("RepositoryMock.CreateIncomeFunc: method is nil but Repository.CreateIncome was just called")
	}
	callInfo := struct {
		UID    string
		Income model.Income
	}{
		UID:    uid,
		Income: income,
	}
	mock.lockCreateIncome.Lock()
	mock.calls.CreateIncome = append(mock.calls.CreateIncome, callInfo)
	mock.lockCreateIncome.Unlock()
	return mock.CreateIncomeFunc(uid, income)
}

// CreateIncomeCalls gets all the calls that were made to CreateIncome.
// Check the length with:
//
//	len(mockedRepository.CreateIncomeCalls())
func (mock *RepositoryMock) CreateIncomeCalls() []struct {
	UID    string
	Income model.Income
} {
	var calls []struct {
		UID    string
		Income model.Income
	}
	mock.lockCreateIncome.RLock()
	calls = mock.calls.CreateIncome
	mock.lockCreateIncome.RUnlock()
	return calls
}

// DeleteExpense calls DeleteExpenseFunc.
func (mock *RepositoryMock) DeleteExpense(id string, uid string) error {
	if mock.DeleteExpenseFunc == nil {
		panic("RepositoryMock.DeleteExpenseFunc: method is nil but Repository.DeleteExpense was just called")
	}
	callInfo := struct {
		ID  string
		UID string
	}{
		ID:  id,
		UID: uid,
	}
	mock.lockDeleteExpense.Lock()
	mock.calls.DeleteExpense = append(mock.calls.DeleteExpense, callInfo)
	mock.lockDeleteExpense.Unlock()
	return mock.DeleteExpenseFunc(id, uid)
}

// DeleteExpenseCalls gets all the calls that were made to DeleteExpense.
// Check the length with:
//
//	len(mockedRepository.DeleteExpenseCalls())
func (mock *RepositoryMock) DeleteExpenseCalls() []struct {
	ID  string
	UID string
} {
	var calls []struct {
		ID  string
		UID string
	}
	mock.lockDeleteExpense.RLock()
	calls = mock.calls.DeleteExpense
	mock.lockDeleteExpense.RUnlock()
	return calls
}

// DeleteExpenseSchedule calls DeleteExpenseScheduleFunc.
func (mock *RepositoryMock) DeleteExpenseSchedule(id string, uid string) error {
	if mock.DeleteExpenseScheduleFunc == nil {
		panic("RepositoryMock.DeleteExpenseScheduleFunc: method is nil but Repository.DeleteExpenseSchedule was just called")
	}
	callInfo := struct {
		ID  string
		UID string
	}{
		ID:  id,
		UID: uid,
	}
	mock.lockDeleteExpenseSchedule.Lock()
	mock.calls.DeleteExpenseSchedule = append(mock.calls.DeleteExpenseSchedule, callInfo)
	mock.lockDeleteExpenseSchedule.Unlock()
	return mock.DeleteExpenseScheduleFunc(id, uid)
}

// DeleteExpenseScheduleCalls gets all the calls that were made to DeleteExpenseSchedule.
// Check the length with:
//
//	len(mockedRepository.DeleteExpenseScheduleCalls())
func (mock *RepositoryMock) DeleteExpenseScheduleCalls() []struct {
	ID  string
	UID string
} {
	var calls []struct {
		ID  string
		UID string
	}
	mock.lockDeleteExpenseSchedule.RLock()
	calls = mock.calls.DeleteExpenseSchedule
	mock.lockDeleteExpenseSchedule.RUnlock()
	return calls
}

// DeleteIncomeSchedule calls DeleteIncomeScheduleFunc.
func (mock *RepositoryMock) DeleteIncomeSchedule(id string, uid string) error {
	if mock.DeleteIncomeScheduleFunc == nil {
		panic("RepositoryMock.DeleteIncomeScheduleFunc: method is nil but Repository.DeleteIncomeSchedule was just called")
	}
	callInfo := struct {
		ID  string
		UID string
	}{
		ID:  id,
		UID: uid,
	}
	mock.lockDeleteIncomeSchedule.Lock()
	mock.calls.DeleteIncomeSchedule = append(mock.calls.DeleteIncomeSchedule, callInfo)
	mock.lockDeleteIncomeSchedule.Unlock()
	return mock.DeleteIncomeScheduleFunc(id, uid)
}

// DeleteIncomeScheduleCalls gets all the calls that were made to DeleteIncomeSchedule.
// Check the length with:
//
//	len(mockedRepository.DeleteIncomeScheduleCalls())
func (mock *RepositoryMock) DeleteIncomeScheduleCalls() []struct {
	ID  string
	UID string
} {
	var calls []struct {
		ID  string
		UID string
	}
	mock.lockDeleteIncomeSchedule.RLock()
	calls = mock.calls.DeleteIncomeSchedule
	mock.lockDeleteIncomeSchedule.RUnlock()
	return calls
}

// FindAllUIDs calls FindAllUIDsFunc.
func (mock *RepositoryMock) FindAllUIDs() ([]string, error) {
	if mock.FindAllUIDsFunc == nil {
		panic("RepositoryMock.FindAllUIDsFunc: method is nil but Repository.FindAllUIDs was just called")
	}
	callInfo := struct {
	}{}
	mock.lockFindAllUIDs.Lock()
	mock.calls.FindAllUIDs = append(mock.calls.FindAllUIDs, callInfo)
	mock.lockFindAllUIDs.Unlock()
	return mock.FindAllUIDsFunc()
}

// FindAllUIDsCalls gets all the calls that were made to FindAllUIDs.
// Check the length with:
//
//	len(mockedRepository.FindAllUIDsCalls())
func (mock *RepositoryMock) FindAllUIDsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFindAllUIDs.RLock()
	calls = mock.calls.FindAllUIDs
	mock.lockFindAllUIDs.RUnlock()
	return calls
}

// FindColumnChartExpenseData calls FindColumnChartExpenseDataFunc.
func (mock *RepositoryMock) FindColumnChartExpenseData(uid string) ([]repositories.ColumnChartData, error) {
	if mock.FindColumnChartExpenseDataFunc == nil {
		panic("RepositoryMock.FindColumnChartExpenseDataFunc: method is nil but Repository.FindColumnChartExpenseData was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockFindColumnChartExpenseData.Lock()
	mock.calls.FindColumnChartExpenseData = append(mock.calls.FindColumnChartExpenseData, callInfo)
	mock.lockFindColumnChartExpenseData.Unlock()
	return mock.FindColumnChartExpenseDataFunc(uid)
}

// FindColumnChartExpenseDataCalls gets all the calls that were made to FindColumnChartExpenseData.
// Check the length with:
//
//	len(mockedRepository.FindColumnChartExpenseDataCalls())
func (mock *RepositoryMock) FindColumnChartExpenseDataCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockFindColumnChartExpenseData.RLock()
	calls = mock.calls.FindColumnChartExpenseData
	mock.lockFindColumnChartExpenseData.RUnlock()
	return calls
}

// FindColumnChartIncomeData calls FindColumnChartIncomeDataFunc.
func (mock *RepositoryMock) FindColumnChartIncomeData(uid string) ([]repositories.ColumnChartData, error) {
	if mock.FindColumnChartIncomeDataFunc == nil {
		panic("RepositoryMock.FindColumnChartIncomeDataFunc: method is nil but Repository.FindColumnChartIncomeData was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockFindColumnChartIncomeData.Lock()
	mock.calls.FindColumnChartIncomeData = append(mock.calls.FindColumnChartIncomeData, callInfo)
	mock.lockFindColumnChartIncomeData.Unlock()
	return mock.FindColumnChartIncomeDataFunc(uid)
}

// FindColumnChartIncomeDataCalls gets all the calls that were made to FindColumnChartIncomeData.
// Check the length with:
//
//	len(mockedRepository.FindColumnChartIncomeDataCalls())
func (mock *RepositoryMock) FindColumnChartIncomeDataCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockFindColumnChartIncomeData.RLock()
	calls = mock.calls.FindColumnChartIncomeData
	mock.lockFindColumnChartIncomeData.RUnlock()
	return calls
}

// FindExpense calls FindExpenseFunc.
func (mock *RepositoryMock) FindExpense(id string, uid string) (model.Expense, error) {
	if mock.FindExpenseFunc == nil {
		panic("RepositoryMock.FindExpenseFunc: method is nil but Repository.FindExpense was just called")
	}
	callInfo := struct {
		ID  string
		UID string
	}{
		ID:  id,
		UID: uid,
	}
	mock.lockFindExpense.Lock()
	mock.calls.FindExpense = append(mock.calls.FindExpense, callInfo)
	mock.lockFindExpense.Unlock()
	return mock.FindExpenseFunc(id, uid)
}

// FindExpenseCalls gets all the calls that were made to FindExpense.
// Check the length with:
//
//	len(mockedRepository.FindExpenseCalls())
func (mock *RepositoryMock) FindExpenseCalls() []struct {
	ID  string
	UID string
} {
	var calls []struct {
		ID  string
		UID string
	}
	mock.lockFindExpense.RLock()
	calls = mock.calls.FindExpense
	mock.lockFindExpense.RUnlock()
	return calls
}

// FindExpenseCategories calls FindExpenseCategoriesFunc.
func (mock *RepositoryMock) FindExpenseCategories(uid string) ([]model.ExpenseCategory, error) {
	if mock.FindExpenseCategoriesFunc == nil {
		panic("RepositoryMock.FindExpenseCategoriesFunc: method is nil but Repository.FindExpenseCategories was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockFindExpenseCategories.Lock()
	mock.calls.FindExpenseCategories = append(mock.calls.FindExpenseCategories, callInfo)
	mock.lockFindExpenseCategories.Unlock()
	return mock.FindExpenseCategoriesFunc(uid)
}

// FindExpenseCategoriesCalls gets all the calls that were made to FindExpenseCategories.
// Check the length with:
//
//	len(mockedRepository.FindExpenseCategoriesCalls())
func (mock *RepositoryMock) FindExpenseCategoriesCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockFindExpenseCategories.RLock()
	calls = mock.calls.FindExpenseCategories
	mock.lockFindExpenseCategories.RUnlock()
	return calls
}

// FindExpenseCategory calls FindExpenseCategoryFunc.
func (mock *RepositoryMock) FindExpenseCategory(id string, uid string) (model.ExpenseCategory, error) {
	if mock.FindExpenseCategoryFunc == nil {
		panic("RepositoryMock.FindExpenseCategoryFunc: method is nil but Repository.FindExpenseCategory was just called")
	}
	callInfo := struct {
		ID  string
		UID string
	}{
		ID:  id,
		UID: uid,
	}
	mock.lockFindExpenseCategory.Lock()
	mock.calls.FindExpenseCategory = append(mock.calls.FindExpenseCategory, callInfo)
	mock.lockFindExpenseCategory.Unlock()
	return mock.FindExpenseCategoryFunc(id, uid)
}

// FindExpenseCategoryCalls gets all the calls that were made to FindExpenseCategory.
// Check the length with:
//
//	len(mockedRepository.FindExpenseCategoryCalls())
func (mock *RepositoryMock) FindExpenseCategoryCalls() []struct {
	ID  string
	UID string
} {
	var calls []struct {
		ID  string
		UID string
	}
	mock.lockFindExpenseCategory.RLock()
	calls = mock.calls.FindExpenseCategory
	mock.lockFindExpenseCategory.RUnlock()
	return calls
}

// FindExpenseLocation calls FindExpenseLocationFunc.
func (mock *RepositoryMock) FindExpenseLocation(id string, uid string) (model.ExpenseLocation, error) {
	if mock.FindExpenseLocationFunc == nil {
		panic("RepositoryMock.FindExpenseLocationFunc: method is nil but Repository.FindExpenseLocation was just called")
	}
	callInfo := struct {
		ID  string
		UID string
	}{
		ID:  id,
		UID: uid,
	}
	mock.lockFindExpenseLocation.Lock()
	mock.calls.FindExpenseLocation = append(mock.calls.FindExpenseLocation, callInfo)
	mock.lockFindExpenseLocation.Unlock()
	return mock.FindExpenseLocationFunc(id, uid)
}

// FindExpenseLocationCalls gets all the calls that were made to FindExpenseLocation.
// Check the length with:
//
//	len(mockedRepository.FindExpenseLocationCalls())
func (mock *RepositoryMock) FindExpenseLocationCalls() []struct {
	ID  string
	UID string
} {
	var calls []struct {
		ID  string
		UID string
	}
	mock.lockFindExpenseLocation.RLock()
	calls = mock.calls.FindExpenseLocation
	mock.lockFindExpenseLocation.RUnlock()
	return calls
}

// FindExpenseLocations calls FindExpenseLocationsFunc.
func (mock *RepositoryMock) FindExpenseLocations(uid string) ([]model.ExpenseLocation, error) {
	if mock.FindExpenseLocationsFunc == nil {
		panic("RepositoryMock.FindExpenseLocationsFunc: method is nil but Repository.FindExpenseLocations was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockFindExpenseLocations.Lock()
	mock.calls.FindExpenseLocations = append(mock.calls.FindExpenseLocations, callInfo)
	mock.lockFindExpenseLocations.Unlock()
	return mock.FindExpenseLocationsFunc(uid)
}

// FindExpenseLocationsCalls gets all the calls that were made to FindExpenseLocations.
// Check the length with:
//
//	len(mockedRepository.FindExpenseLocationsCalls())
func (mock *RepositoryMock) FindExpenseLocationsCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockFindExpenseLocations.RLock()
	calls = mock.calls.FindExpenseLocations
	mock.lockFindExpenseLocations.RUnlock()
	return calls
}

// FindExpenseSchedule calls FindExpenseScheduleFunc.
func (mock *RepositoryMock) FindExpenseSchedule(id string, uid string) (model.ExpenseSchedule, error) {
	if mock.FindExpenseScheduleFunc == nil {
		panic("RepositoryMock.FindExpenseScheduleFunc: method is nil but Repository.FindExpenseSchedule was just called")
	}
	callInfo := struct {
		ID  string
		UID string
	}{
		ID:  id,
		UID: uid,
	}
	mock.lockFindExpenseSchedule.Lock()
	mock.calls.FindExpenseSchedule = append(mock.calls.FindExpenseSchedule, callInfo)
	mock.lockFindExpenseSchedule.Unlock()
	return mock.FindExpenseScheduleFunc(id, uid)
}

// FindExpenseScheduleCalls gets all the calls that were made to FindExpenseSchedule.
// Check the length with:
//
//	len(mockedRepository.FindExpenseScheduleCalls())
func (mock *RepositoryMock) FindExpenseScheduleCalls() []struct {
	ID  string
	UID string
} {
	var calls []struct {
		ID  string
		UID string
	}
	mock.lockFindExpenseSchedule.RLock()
	calls = mock.calls.FindExpenseSchedule
	mock.lockFindExpenseSchedule.RUnlock()
	return calls
}

// FindExpenseSchedules calls FindExpenseSchedulesFunc.
func (mock *RepositoryMock) FindExpenseSchedules(uid string) ([]model.ExpenseSchedule, error) {
	if mock.FindExpenseSchedulesFunc == nil {
		panic("RepositoryMock.FindExpenseSchedulesFunc: method is nil but Repository.FindExpenseSchedules was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockFindExpenseSchedules.Lock()
	mock.calls.FindExpenseSchedules = append(mock.calls.FindExpenseSchedules, callInfo)
	mock.lockFindExpenseSchedules.Unlock()
	return mock.FindExpenseSchedulesFunc(uid)
}

// FindExpenseSchedulesCalls gets all the calls that were made to FindExpenseSchedules.
// Check the length with:
//
//	len(mockedRepository.FindExpenseSchedulesCalls())
func (mock *RepositoryMock) FindExpenseSchedulesCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockFindExpenseSchedules.RLock()
	calls = mock.calls.FindExpenseSchedules
	mock.lockFindExpenseSchedules.RUnlock()
	return calls
}

// FindExpenses calls FindExpensesFunc.
func (mock *RepositoryMock) FindExpenses(uid string, start *time.Time, end *time.Time) ([]model.Expense, error) {
	if mock.FindExpensesFunc == nil {
		panic("RepositoryMock.FindExpensesFunc: method is nil but Repository.FindExpenses was just called")
	}
	callInfo := struct {
		UID   string
		Start *time.Time
		End   *time.Time
	}{
		UID:   uid,
		Start: start,
		End:   end,
	}
	mock.lockFindExpenses.Lock()
	mock.calls.FindExpenses = append(mock.calls.FindExpenses, callInfo)
	mock.lockFindExpenses.Unlock()
	return mock.FindExpensesFunc(uid, start, end)
}

// FindExpensesCalls gets all the calls that were made to FindExpenses.
// Check the length with:
//
//	len(mockedRepository.FindExpensesCalls())
func (mock *RepositoryMock) FindExpensesCalls() []struct {
	UID   string
	Start *time.Time
	End   *time.Time
} {
	var calls []struct {
		UID   string
		Start *time.Time
		End   *time.Time
	}
	mock.lockFindExpenses.RLock()
	calls = mock.calls.FindExpenses
	mock.lockFindExpenses.RUnlock()
	return calls
}

// FindIncome calls FindIncomeFunc.
func (mock *RepositoryMock) FindIncome(id string, uid string) (model.Income, error) {
	if mock.FindIncomeFunc == nil {
		panic("RepositoryMock.FindIncomeFunc: method is nil but Repository.FindIncome was just called")
	}
	callInfo := struct {
		ID  string
		UID string
	}{
		ID:  id,
		UID: uid,
	}
	mock.lockFindIncome.Lock()
	mock.calls.FindIncome = append(mock.calls.FindIncome, callInfo)
	mock.lockFindIncome.Unlock()
	return mock.FindIncomeFunc(id, uid)
}

// FindIncomeCalls gets all the calls that were made to FindIncome.
// Check the length with:
//
//	len(mockedRepository.FindIncomeCalls())
func (mock *RepositoryMock) FindIncomeCalls() []struct {
	ID  string
	UID string
} {
	var calls []struct {
		ID  string
		UID string
	}
	mock.lockFindIncome.RLock()
	calls = mock.calls.FindIncome
	mock.lockFindIncome.RUnlock()
	return calls
}

// FindIncomeSchedule calls FindIncomeScheduleFunc.
func (mock *RepositoryMock) FindIncomeSchedule(id string, uid string) (model.IncomeSchedule, error) {
	if mock.FindIncomeScheduleFunc == nil {
		panic("RepositoryMock.FindIncomeScheduleFunc: method is nil but Repository.FindIncomeSchedule was just called")
	}
	callInfo := struct {
		ID  string
		UID string
	}{
		ID:  id,
		UID: uid,
	}
	mock.lockFindIncomeSchedule.Lock()
	mock.calls.FindIncomeSchedule = append(mock.calls.FindIncomeSchedule, callInfo)
	mock.lockFindIncomeSchedule.Unlock()
	return mock.FindIncomeScheduleFunc(id, uid)
}

// FindIncomeScheduleCalls gets all the calls that were made to FindIncomeSchedule.
// Check the length with:
//
//	len(mockedRepository.FindIncomeScheduleCalls())
func (mock *RepositoryMock) FindIncomeScheduleCalls() []struct {
	ID  string
	UID string
} {
	var calls []struct {
		ID  string
		UID string
	}
	mock.lockFindIncomeSchedule.RLock()
	calls = mock.calls.FindIncomeSchedule
	mock.lockFindIncomeSchedule.RUnlock()
	return calls
}

// FindIncomeSchedules calls FindIncomeSchedulesFunc.
func (mock *RepositoryMock) FindIncomeSchedules(uid string) ([]model.IncomeSchedule, error) {
	if mock.FindIncomeSchedulesFunc == nil {
		panic("RepositoryMock.FindIncomeSchedulesFunc: method is nil but Repository.FindIncomeSchedules was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockFindIncomeSchedules.Lock()
	mock.calls.FindIncomeSchedules = append(mock.calls.FindIncomeSchedules, callInfo)
	mock.lockFindIncomeSchedules.Unlock()
	return mock.FindIncomeSchedulesFunc(uid)
}

// FindIncomeSchedulesCalls gets all the calls that were made to FindIncomeSchedules.
// Check the length with:
//
//	len(mockedRepository.FindIncomeSchedulesCalls())
func (mock *RepositoryMock) FindIncomeSchedulesCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockFindIncomeSchedules.RLock()
	calls = mock.calls.FindIncomeSchedules
	mock.lockFindIncomeSchedules.RUnlock()
	return calls
}

// FindIncomeTypes calls FindIncomeTypesFunc.
func (mock *RepositoryMock) FindIncomeTypes(uid string) ([]model.IncomeType, error) {
	if mock.FindIncomeTypesFunc == nil {
		panic("RepositoryMock.FindIncomeTypesFunc: method is nil but Repository.FindIncomeTypes was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockFindIncomeTypes.Lock()
	mock.calls.FindIncomeTypes = append(mock.calls.FindIncomeTypes, callInfo)
	mock.lockFindIncomeTypes.Unlock()
	return mock.FindIncomeTypesFunc(uid)
}

// FindIncomeTypesCalls gets all the calls that were made to FindIncomeTypes.
// Check the length with:
//
//	len(mockedRepository.FindIncomeTypesCalls())
func (mock *RepositoryMock) FindIncomeTypesCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockFindIncomeTypes.RLock()
	calls = mock.calls.FindIncomeTypes
	mock.lockFindIncomeTypes.RUnlock()
	return calls
}

// FindIncomes calls FindIncomesFunc.
func (mock *RepositoryMock) FindIncomes(uid string, start *time.Time, end *time.Time) ([]model.Income, error) {
	if mock.FindIncomesFunc == nil {
		panic("RepositoryMock.FindIncomesFunc: method is nil but Repository.FindIncomes was just called")
	}
	callInfo := struct {
		UID   string
		Start *time.Time
		End   *time.Time
	}{
		UID:   uid,
		Start: start,
		End:   end,
	}
	mock.lockFindIncomes.Lock()
	mock.calls.FindIncomes = append(mock.calls.FindIncomes, callInfo)
	mock.lockFindIncomes.Unlock()
	return mock.FindIncomesFunc(uid, start, end)
}

// FindIncomesCalls gets all the calls that were made to FindIncomes.
// Check the length with:
//
//	len(mockedRepository.FindIncomesCalls())
func (mock *RepositoryMock) FindIncomesCalls() []struct {
	UID   string
	Start *time.Time
	End   *time.Time
} {
	var calls []struct {
		UID   string
		Start *time.Time
		End   *time.Time
	}
	mock.lockFindIncomes.RLock()
	calls = mock.calls.FindIncomes
	mock.lockFindIncomes.RUnlock()
	return calls
}

// FindOrCreateExpenseCategory calls FindOrCreateExpenseCategoryFunc.
func (mock *RepositoryMock) FindOrCreateExpenseCategory(uid string, name string) (model.ExpenseCategory, error) {
	if mock.FindOrCreateExpenseCategoryFunc == nil {
		panic("RepositoryMock.FindOrCreateExpenseCategoryFunc: method is nil but Repository.FindOrCreateExpenseCategory was just called")
	}
	callInfo := struct {
		UID  string
		Name string
	}{
		UID:  uid,
		Name: name,
	}
	mock.lockFindOrCreateExpenseCategory.Lock()
	mock.calls.FindOrCreateExpenseCategory = append(mock.calls.FindOrCreateExpenseCategory, callInfo)
	mock.lockFindOrCreateExpenseCategory.Unlock()
	return mock.FindOrCreateExpenseCategoryFunc(uid, name)
}

// FindOrCreateExpenseCategoryCalls gets all the calls that were made to FindOrCreateExpenseCategory.
// Check the length with:
//
//	len(mockedRepository.FindOrCreateExpenseCategoryCalls())
func (mock *RepositoryMock) FindOrCreateExpenseCategoryCalls() []struct {
	UID  string
	Name string
} {
	var calls []struct {
		UID  string
		Name string
	}
	mock.lockFindOrCreateExpenseCategory.RLock()
	calls = mock.calls.FindOrCreateExpenseCategory
	mock.lockFindOrCreateExpenseCategory.RUnlock()
	return calls
}

// FindOrCreateExpenseLocation calls FindOrCreateExpenseLocationFunc.
func (mock *RepositoryMock) FindOrCreateExpenseLocation(uid string, name string) (model.ExpenseLocation, error) {
	if mock.FindOrCreateExpenseLocationFunc == nil {
		panic("RepositoryMock.FindOrCreateExpenseLocationFunc: method is nil but Repository.FindOrCreateExpenseLocation was just called")
	}
	callInfo := struct {
		UID  string
		Name string
	}{
		UID:  uid,
		Name: name,
	}
	mock.lockFindOrCreateExpenseLocation.Lock()
	mock.calls.FindOrCreateExpenseLocation = append(mock.calls.FindOrCreateExpenseLocation, callInfo)
	mock.lockFindOrCreateExpenseLocation.Unlock()
	return mock.FindOrCreateExpenseLocationFunc(uid, name)
}

// FindOrCreateExpenseLocationCalls gets all the calls that were made to FindOrCreateExpenseLocation.
// Check the length with:
//
//	len(mockedRepository.FindOrCreateExpenseLocationCalls())
func (mock *RepositoryMock) FindOrCreateExpenseLocationCalls() []struct {
	UID  string
	Name string
} {
	var calls []struct {
		UID  string
		Name string
	}
	mock.lockFindOrCreateExpenseLocation.RLock()
	calls = mock.calls.FindOrCreateExpenseLocation
	mock.lockFindOrCreateExpenseLocation.RUnlock()
	return calls
}

// FindOrCreateIncomeType calls FindOrCreateIncomeTypeFunc.
func (mock *RepositoryMock) FindOrCreateIncomeType(uid string, name string) (model.IncomeType, error) {
	if mock.FindOrCreateIncomeTypeFunc == nil {
		panic("RepositoryMock.FindOrCreateIncomeTypeFunc: method is nil but Repository.FindOrCreateIncomeType was just called")
	}
	callInfo := struct {
		UID  string
		Name string
	}{
		UID:  uid,
		Name: name,
	}
	mock.lockFindOrCreateIncomeType.Lock()
	mock.calls.FindOrCreateIncomeType = append(mock.calls.FindOrCreateIncomeType, callInfo)
	mock.lockFindOrCreateIncomeType.Unlock()
	return mock.FindOrCreateIncomeTypeFunc(uid, name)
}

// FindOrCreateIncomeTypeCalls gets all the calls that were made to FindOrCreateIncomeType.
// Check the length with:
//
//	len(mockedRepository.FindOrCreateIncomeTypeCalls())
func (mock *RepositoryMock) FindOrCreateIncomeTypeCalls() []struct {
	UID  string
	Name string
} {
	var calls []struct {
		UID  string
		Name string
	}
	mock.lockFindOrCreateIncomeType.RLock()
	calls = mock.calls.FindOrCreateIncomeType
	mock.lockFindOrCreateIncomeType.RUnlock()
	return calls
}

// FindOrCreateUser calls FindOrCreateUserFunc.
func (mock *RepositoryMock) FindOrCreateUser(uid string) (model.User, error) {
	if mock.FindOrCreateUserFunc == nil {
		panic("RepositoryMock.FindOrCreateUserFunc: method is nil but Repository.FindOrCreateUser was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockFindOrCreateUser.Lock()
	mock.calls.FindOrCreateUser = append(mock.calls.FindOrCreateUser, callInfo)
	mock.lockFindOrCreateUser.Unlock()
	return mock.FindOrCreateUserFunc(uid)
}

// FindOrCreateUserCalls gets all the calls that were made to FindOrCreateUser.
// Check the length with:
//
//	len(mockedRepository.FindOrCreateUserCalls())
func (mock *RepositoryMock) FindOrCreateUserCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockFindOrCreateUser.RLock()
	calls = mock.calls.FindOrCreateUser
	mock.lockFindOrCreateUser.RUnlock()
	return calls
}

// FindPieChartCategoryData calls FindPieChartCategoryDataFunc.
func (mock *RepositoryMock) FindPieChartCategoryData(uid string, start *time.Time, end *time.Time) ([]repositories.PieChartData, error) {
	if mock.FindPieChartCategoryDataFunc == nil {
		panic("RepositoryMock.FindPieChartCategoryDataFunc: method is nil but Repository.FindPieChartCategoryData was just called")
	}
	callInfo := struct {
		UID   string
		Start *time.Time
		End   *time.Time
	}{
		UID:   uid,
		Start: start,
		End:   end,
	}
	mock.lockFindPieChartCategoryData.Lock()
	mock.calls.FindPieChartCategoryData = append(mock.calls.FindPieChartCategoryData, callInfo)
	mock.lockFindPieChartCategoryData.Unlock()
	return mock.FindPieChartCategoryDataFunc(uid, start, end)
}

// FindPieChartCategoryDataCalls gets all the calls that were made to FindPieChartCategoryData.
// Check the length with:
//
//	len(mockedRepository.FindPieChartCategoryDataCalls())
func (mock *RepositoryMock) FindPieChartCategoryDataCalls() []struct {
	UID   string
	Start *time.Time
	End   *time.Time
} {
	var calls []struct {
		UID   string
		Start *time.Time
		End   *time.Time
	}
	mock.lockFindPieChartCategoryData.RLock()
	calls = mock.calls.FindPieChartCategoryData
	mock.lockFindPieChartCategoryData.RUnlock()
	return calls
}

// FindPieChartLocationData calls FindPieChartLocationDataFunc.
func (mock *RepositoryMock) FindPieChartLocationData(uid string, start *time.Time, end *time.Time) ([]repositories.PieChartData, error) {
	if mock.FindPieChartLocationDataFunc == nil {
		panic("RepositoryMock.FindPieChartLocationDataFunc: method is nil but Repository.FindPieChartLocationData was just called")
	}
	callInfo := struct {
		UID   string
		Start *time.Time
		End   *time.Time
	}{
		UID:   uid,
		Start: start,
		End:   end,
	}
	mock.lockFindPieChartLocationData.Lock()
	mock.calls.FindPieChartLocationData = append(mock.calls.FindPieChartLocationData, callInfo)
	mock.lockFindPieChartLocationData.Unlock()
	return mock.FindPieChartLocationDataFunc(uid, start, end)
}

// FindPieChartLocationDataCalls gets all the calls that were made to FindPieChartLocationData.
// Check the length with:
//
//	len(mockedRepository.FindPieChartLocationDataCalls())
func (mock *RepositoryMock) FindPieChartLocationDataCalls() []struct {
	UID   string
	Start *time.Time
	End   *time.Time
} {
	var calls []struct {
		UID   string
		Start *time.Time
		End   *time.Time
	}
	mock.lockFindPieChartLocationData.RLock()
	calls = mock.calls.FindPieChartLocationData
	mock.lockFindPieChartLocationData.RUnlock()
	return calls
}

// FindTransactionMonths calls FindTransactionMonthsFunc.
func (mock *RepositoryMock) FindTransactionMonths(uid string) ([]string, error) {
	if mock.FindTransactionMonthsFunc == nil {
		panic("RepositoryMock.FindTransactionMonthsFunc: method is nil but Repository.FindTransactionMonths was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockFindTransactionMonths.Lock()
	mock.calls.FindTransactionMonths = append(mock.calls.FindTransactionMonths, callInfo)
	mock.lockFindTransactionMonths.Unlock()
	return mock.FindTransactionMonthsFunc(uid)
}

// FindTransactionMonthsCalls gets all the calls that were made to FindTransactionMonths.
// Check the length with:
//
//	len(mockedRepository.FindTransactionMonthsCalls())
func (mock *RepositoryMock) FindTransactionMonthsCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockFindTransactionMonths.RLock()
	calls = mock.calls.FindTransactionMonths
	mock.lockFindTransactionMonths.RUnlock()
	return calls
}

// HardDeleteAllUserExpenseCategories calls HardDeleteAllUserExpenseCategoriesFunc.
func (mock *RepositoryMock) HardDeleteAllUserExpenseCategories(uid string) error {
	if mock.HardDeleteAllUserExpenseCategoriesFunc == nil {
		panic("RepositoryMock.HardDeleteAllUserExpenseCategoriesFunc: method is nil but Repository.HardDeleteAllUserExpenseCategories was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockHardDeleteAllUserExpenseCategories.Lock()
	mock.calls.HardDeleteAllUserExpenseCategories = append(mock.calls.HardDeleteAllUserExpenseCategories, callInfo)
	mock.lockHardDeleteAllUserExpenseCategories.Unlock()
	return mock.HardDeleteAllUserExpenseCategoriesFunc(uid)
}

// HardDeleteAllUserExpenseCategoriesCalls gets all the calls that were made to HardDeleteAllUserExpenseCategories.
// Check the length with:
//
//	len(mockedRepository.HardDeleteAllUserExpenseCategoriesCalls())
func (mock *RepositoryMock) HardDeleteAllUserExpenseCategoriesCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockHardDeleteAllUserExpenseCategories.RLock()
	calls = mock.calls.HardDeleteAllUserExpenseCategories
	mock.lockHardDeleteAllUserExpenseCategories.RUnlock()
	return calls
}

// HardDeleteAllUserExpenseLocations calls HardDeleteAllUserExpenseLocationsFunc.
func (mock *RepositoryMock) HardDeleteAllUserExpenseLocations(uid string) error {
	if mock.HardDeleteAllUserExpenseLocationsFunc == nil {
		panic("RepositoryMock.HardDeleteAllUserExpenseLocationsFunc: method is nil but Repository.HardDeleteAllUserExpenseLocations was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockHardDeleteAllUserExpenseLocations.Lock()
	mock.calls.HardDeleteAllUserExpenseLocations = append(mock.calls.HardDeleteAllUserExpenseLocations, callInfo)
	mock.lockHardDeleteAllUserExpenseLocations.Unlock()
	return mock.HardDeleteAllUserExpenseLocationsFunc(uid)
}

// HardDeleteAllUserExpenseLocationsCalls gets all the calls that were made to HardDeleteAllUserExpenseLocations.
// Check the length with:
//
//	len(mockedRepository.HardDeleteAllUserExpenseLocationsCalls())
func (mock *RepositoryMock) HardDeleteAllUserExpenseLocationsCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockHardDeleteAllUserExpenseLocations.RLock()
	calls = mock.calls.HardDeleteAllUserExpenseLocations
	mock.lockHardDeleteAllUserExpenseLocations.RUnlock()
	return calls
}

// HardDeleteAllUserExpenses calls HardDeleteAllUserExpensesFunc.
func (mock *RepositoryMock) HardDeleteAllUserExpenses(uid string) error {
	if mock.HardDeleteAllUserExpensesFunc == nil {
		panic("RepositoryMock.HardDeleteAllUserExpensesFunc: method is nil but Repository.HardDeleteAllUserExpenses was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockHardDeleteAllUserExpenses.Lock()
	mock.calls.HardDeleteAllUserExpenses = append(mock.calls.HardDeleteAllUserExpenses, callInfo)
	mock.lockHardDeleteAllUserExpenses.Unlock()
	return mock.HardDeleteAllUserExpensesFunc(uid)
}

// HardDeleteAllUserExpensesCalls gets all the calls that were made to HardDeleteAllUserExpenses.
// Check the length with:
//
//	len(mockedRepository.HardDeleteAllUserExpensesCalls())
func (mock *RepositoryMock) HardDeleteAllUserExpensesCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockHardDeleteAllUserExpenses.RLock()
	calls = mock.calls.HardDeleteAllUserExpenses
	mock.lockHardDeleteAllUserExpenses.RUnlock()
	return calls
}

// HardDeleteAllUserIncomes calls HardDeleteAllUserIncomesFunc.
func (mock *RepositoryMock) HardDeleteAllUserIncomes(uid string) error {
	if mock.HardDeleteAllUserIncomesFunc == nil {
		panic("RepositoryMock.HardDeleteAllUserIncomesFunc: method is nil but Repository.HardDeleteAllUserIncomes was just called")
	}
	callInfo := struct {
		UID string
	}{
		UID: uid,
	}
	mock.lockHardDeleteAllUserIncomes.Lock()
	mock.calls.HardDeleteAllUserIncomes = append(mock.calls.HardDeleteAllUserIncomes, callInfo)
	mock.lockHardDeleteAllUserIncomes.Unlock()
	return mock.HardDeleteAllUserIncomesFunc(uid)
}

// HardDeleteAllUserIncomesCalls gets all the calls that were made to HardDeleteAllUserIncomes.
// Check the length with:
//
//	len(mockedRepository.HardDeleteAllUserIncomesCalls())
func (mock *RepositoryMock) HardDeleteAllUserIncomesCalls() []struct {
	UID string
} {
	var calls []struct {
		UID string
	}
	mock.lockHardDeleteAllUserIncomes.RLock()
	calls = mock.calls.HardDeleteAllUserIncomes
	mock.lockHardDeleteAllUserIncomes.RUnlock()
	return calls
}

// Transaction calls TransactionFunc.
func (mock *RepositoryMock) Transaction(fc func(txRepo *repositories.SuitoRepository) error, opts ...*sql.TxOptions) error {
	if mock.TransactionFunc == nil {
		panic("RepositoryMock.TransactionFunc: method is nil but Repository.Transaction was just called")
	}
	callInfo := struct {
		Fc   func(txRepo *repositories.SuitoRepository) error
		Opts []*sql.TxOptions
	}{
		Fc:   fc,
		Opts: opts,
	}
	mock.lockTransaction.Lock()
	mock.calls.Transaction = append(mock.calls.Transaction, callInfo)
	mock.lockTransaction.Unlock()
	return mock.TransactionFunc(fc, opts...)
}

// TransactionCalls gets all the calls that were made to Transaction.
// Check the length with:
//
//	len(mockedRepository.TransactionCalls())
func (mock *RepositoryMock) TransactionCalls() []struct {
	Fc   func(txRepo *repositories.SuitoRepository) error
	Opts []*sql.TxOptions
} {
	var calls []struct {
		Fc   func(txRepo *repositories.SuitoRepository) error
		Opts []*sql.TxOptions
	}
	mock.lockTransaction.RLock()
	calls = mock.calls.Transaction
	mock.lockTransaction.RUnlock()
	return calls
}

// UpdateExpense calls UpdateExpenseFunc.
func (mock *RepositoryMock) UpdateExpense(uid string, expense model.Expense) (model.Expense, error) {
	if mock.UpdateExpenseFunc == nil {
		panic("RepositoryMock.UpdateExpenseFunc: method is nil but Repository.UpdateExpense was just called")
	}
	callInfo := struct {
		UID     string
		Expense model.Expense
	}{
		UID:     uid,
		Expense: expense,
	}
	mock.lockUpdateExpense.Lock()
	mock.calls.UpdateExpense = append(mock.calls.UpdateExpense, callInfo)
	mock.lockUpdateExpense.Unlock()
	return mock.UpdateExpenseFunc(uid, expense)
}

// UpdateExpenseCalls gets all the calls that were made to UpdateExpense.
// Check the length with:
//
//	len(mockedRepository.UpdateExpenseCalls())
func (mock *RepositoryMock) UpdateExpenseCalls() []struct {
	UID     string
	Expense model.Expense
} {
	var calls []struct {
		UID     string
		Expense model.Expense
	}
	mock.lockUpdateExpense.RLock()
	calls = mock.calls.UpdateExpense
	mock.lockUpdateExpense.RUnlock()
	return calls
}

// UpdateExpenseSchedule calls UpdateExpenseScheduleFunc.
func (mock *RepositoryMock) UpdateExpenseSchedule(uid string, schedule model.ExpenseSchedule) (model.ExpenseSchedule, error) {
	if mock.UpdateExpenseScheduleFunc == nil {
		panic("RepositoryMock.UpdateExpenseScheduleFunc: method is nil but Repository.UpdateExpenseSchedule was just called")
	}
	callInfo := struct {
		UID      string
		Schedule model.ExpenseSchedule
	}{
		UID:      uid,
		Schedule: schedule,
	}
	mock.lockUpdateExpenseSchedule.Lock()
	mock.calls.UpdateExpenseSchedule = append(mock.calls.UpdateExpenseSchedule, callInfo)
	mock.lockUpdateExpenseSchedule.Unlock()
	return mock.UpdateExpenseScheduleFunc(uid, schedule)
}

// UpdateExpenseScheduleCalls gets all the calls that were made to UpdateExpenseSchedule.
// Check the length with:
//
//	len(mockedRepository.UpdateExpenseScheduleCalls())
func (mock *RepositoryMock) UpdateExpenseScheduleCalls() []struct {
	UID      string
	Schedule model.ExpenseSchedule
} {
	var calls []struct {
		UID      string
		Schedule model.ExpenseSchedule
	}
	mock.lockUpdateExpenseSchedule.RLock()
	calls = mock.calls.UpdateExpenseSchedule
	mock.lockUpdateExpenseSchedule.RUnlock()
	return calls
}

// UpdateIncome calls UpdateIncomeFunc.
func (mock *RepositoryMock) UpdateIncome(uid string, income model.Income) (model.Income, error) {
	if mock.UpdateIncomeFunc == nil {
		panic("RepositoryMock.UpdateIncomeFunc: method is nil but Repository.UpdateIncome was just called")
	}
	callInfo := struct {
		UID    string
		Income model.Income
	}{
		UID:    uid,
		Income: income,
	}
	mock.lockUpdateIncome.Lock()
	mock.calls.UpdateIncome = append(mock.calls.UpdateIncome, callInfo)
	mock.lockUpdateIncome.Unlock()
	return mock.UpdateIncomeFunc(uid, income)
}

// UpdateIncomeCalls gets all the calls that were made to UpdateIncome.
// Check the length with:
//
//	len(mockedRepository.UpdateIncomeCalls())
func (mock *RepositoryMock) UpdateIncomeCalls() []struct {
	UID    string
	Income model.Income
} {
	var calls []struct {
		UID    string
		Income model.Income
	}
	mock.lockUpdateIncome.RLock()
	calls = mock.calls.UpdateIncome
	mock.lockUpdateIncome.RUnlock()
	return calls
}

// UpdateIncomeSchedule calls UpdateIncomeScheduleFunc.
func (mock *RepositoryMock) UpdateIncomeSchedule(uid string, schedule model.IncomeSchedule) (model.IncomeSchedule, error) {
	if mock.UpdateIncomeScheduleFunc == nil {
		panic("RepositoryMock.UpdateIncomeScheduleFunc: method is nil but Repository.UpdateIncomeSchedule was just called")
	}
	callInfo := struct {
		UID      string
		Schedule model.IncomeSchedule
	}{
		UID:      uid,
		Schedule: schedule,
	}
	mock.lockUpdateIncomeSchedule.Lock()
	mock.calls.UpdateIncomeSchedule = append(mock.calls.UpdateIncomeSchedule, callInfo)
	mock.lockUpdateIncomeSchedule.Unlock()
	return mock.UpdateIncomeScheduleFunc(uid, schedule)
}

// UpdateIncomeScheduleCalls gets all the calls that were made to UpdateIncomeSchedule.
// Check the length with:
//
//	len(mockedRepository.UpdateIncomeScheduleCalls())
func (mock *RepositoryMock) UpdateIncomeScheduleCalls() []struct {
	UID      string
	Schedule model.IncomeSchedule
} {
	var calls []struct {
		UID      string
		Schedule model.IncomeSchedule
	}
	mock.lockUpdateIncomeSchedule.RLock()
	calls = mock.calls.UpdateIncomeSchedule
	mock.lockUpdateIncomeSchedule.RUnlock()
	return calls
}
