// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package client

import (
	"context"
	"firebase.google.com/go/v4/auth"
	"sync"
)

// Ensure, that AuthClientMock does implement AuthClient.
// If this is not the case, regenerate this file with moq.
var _ AuthClient = &AuthClientMock{}

// AuthClientMock is a mock implementation of AuthClient.
//
//	func TestSomethingThatUsesAuthClient(t *testing.T) {
//
//		// make and configure a mocked AuthClient
//		mockedAuthClient := &AuthClientMock{
//			UsersFunc: func(ctx context.Context, nextPageToken string) AuthUserIterator {
//				panic("mock out the Users method")
//			},
//			VerifyIDTokenFunc: func(ctx context.Context, idToken string) (*auth.Token, error) {
//				panic("mock out the VerifyIDToken method")
//			},
//		}
//
//		// use mockedAuthClient in code that requires AuthClient
//		// and then make assertions.
//
//	}
type AuthClientMock struct {
	// UsersFunc mocks the Users method.
	UsersFunc func(ctx context.Context, nextPageToken string) AuthUserIterator

	// VerifyIDTokenFunc mocks the VerifyIDToken method.
	VerifyIDTokenFunc func(ctx context.Context, idToken string) (*auth.Token, error)

	// calls tracks calls to the methods.
	calls struct {
		// Users holds details about calls to the Users method.
		Users []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NextPageToken is the nextPageToken argument value.
			NextPageToken string
		}
		// VerifyIDToken holds details about calls to the VerifyIDToken method.
		VerifyIDToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IdToken is the idToken argument value.
			IdToken string
		}
	}
	lockUsers         sync.RWMutex
	lockVerifyIDToken sync.RWMutex
}

// Users calls UsersFunc.
func (mock *AuthClientMock) Users(ctx context.Context, nextPageToken string) AuthUserIterator {
	if mock.UsersFunc == nil {
		panic("AuthClientMock.UsersFunc: method is nil but AuthClient.Users was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		NextPageToken string
	}{
		Ctx:           ctx,
		NextPageToken: nextPageToken,
	}
	mock.lockUsers.Lock()
	mock.calls.Users = append(mock.calls.Users, callInfo)
	mock.lockUsers.Unlock()
	return mock.UsersFunc(ctx, nextPageToken)
}

// UsersCalls gets all the calls that were made to Users.
// Check the length with:
//
//	len(mockedAuthClient.UsersCalls())
func (mock *AuthClientMock) UsersCalls() []struct {
	Ctx           context.Context
	NextPageToken string
} {
	var calls []struct {
		Ctx           context.Context
		NextPageToken string
	}
	mock.lockUsers.RLock()
	calls = mock.calls.Users
	mock.lockUsers.RUnlock()
	return calls
}

// VerifyIDToken calls VerifyIDTokenFunc.
func (mock *AuthClientMock) VerifyIDToken(ctx context.Context, idToken string) (*auth.Token, error) {
	if mock.VerifyIDTokenFunc == nil {
		panic("AuthClientMock.VerifyIDTokenFunc: method is nil but AuthClient.VerifyIDToken was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		IdToken string
	}{
		Ctx:     ctx,
		IdToken: idToken,
	}
	mock.lockVerifyIDToken.Lock()
	mock.calls.VerifyIDToken = append(mock.calls.VerifyIDToken, callInfo)
	mock.lockVerifyIDToken.Unlock()
	return mock.VerifyIDTokenFunc(ctx, idToken)
}

// VerifyIDTokenCalls gets all the calls that were made to VerifyIDToken.
// Check the length with:
//
//	len(mockedAuthClient.VerifyIDTokenCalls())
func (mock *AuthClientMock) VerifyIDTokenCalls() []struct {
	Ctx     context.Context
	IdToken string
} {
	var calls []struct {
		Ctx     context.Context
		IdToken string
	}
	mock.lockVerifyIDToken.RLock()
	calls = mock.calls.VerifyIDToken
	mock.lockVerifyIDToken.RUnlock()
	return calls
}

// Ensure, that AuthUserIteratorMock does implement AuthUserIterator.
// If this is not the case, regenerate this file with moq.
var _ AuthUserIterator = &AuthUserIteratorMock{}

// AuthUserIteratorMock is a mock implementation of AuthUserIterator.
//
//	func TestSomethingThatUsesAuthUserIterator(t *testing.T) {
//
//		// make and configure a mocked AuthUserIterator
//		mockedAuthUserIterator := &AuthUserIteratorMock{
//			NextFunc: func() (*auth.ExportedUserRecord, error) {
//				panic("mock out the Next method")
//			},
//		}
//
//		// use mockedAuthUserIterator in code that requires AuthUserIterator
//		// and then make assertions.
//
//	}
type AuthUserIteratorMock struct {
	// NextFunc mocks the Next method.
	NextFunc func() (*auth.ExportedUserRecord, error)

	// calls tracks calls to the methods.
	calls struct {
		// Next holds details about calls to the Next method.
		Next []struct {
		}
	}
	lockNext sync.RWMutex
}

// Next calls NextFunc.
func (mock *AuthUserIteratorMock) Next() (*auth.ExportedUserRecord, error) {
	if mock.NextFunc == nil {
		panic("AuthUserIteratorMock.NextFunc: method is nil but AuthUserIterator.Next was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNext.Lock()
	mock.calls.Next = append(mock.calls.Next, callInfo)
	mock.lockNext.Unlock()
	return mock.NextFunc()
}

// NextCalls gets all the calls that were made to Next.
// Check the length with:
//
//	len(mockedAuthUserIterator.NextCalls())
func (mock *AuthUserIteratorMock) NextCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNext.RLock()
	calls = mock.calls.Next
	mock.lockNext.RUnlock()
	return calls
}
